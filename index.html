<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>EnergyPlus eplusout.sql — Offline Dashboard</title>
    <script src="dist/version.js"></script>
    <script>
      try {
        var k = 'eplus_theme';
        var s = localStorage.getItem(k);
        var t =
          s === 'light' || s === 'dark'
            ? s
            : matchMedia('(prefers-color-scheme: dark)').matches
              ? 'dark'
              : 'light';
        document.documentElement.setAttribute('data-theme', t);
      } catch (e) {
        document.documentElement.setAttribute('data-theme', 'light');
      }
    </script>
    <!-- Tailwind CSS compiled locally -->
    <link rel="stylesheet" href="dist/tailwind.css" />
    <!-- Removed legacy CSS variables; using Tailwind semantic classes -->
    <script>
      window.__LIB_URLS__ = {
        d3: 'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js',
        sqljs: 'https://cdn.jsdelivr.net/npm/sql.js@1.8.0/dist/sql-wasm.js',
        sqlwasm: 'https://cdn.jsdelivr.net/npm/sql.js@1.8.0/dist/sql-wasm.wasm',
      };
    </script>
  </head>
  <body
    class="h-screen flex flex-col bg-bg text-text dark:bg-bg-dark dark:text-text-dark transition-colors"
  >
    <header
      class="px-4 py-3 border-b border-border dark:border-border-dark sticky top-0 z-10 backdrop-blur-sm bg-white/95 dark:bg-[#121821]/90"
    >
      <div class="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-3">
        <div class="flex flex-col flex-1 min-w-0">
          <h1 class="text-base font-semibold tracking-wide truncate flex items-baseline gap-2">
            <span>EnergyPlus eplusout.sql Dashboard</span>
            <button
              id="app-version"
              type="button"
              class="text-[11px] font-mono text-muted dark:text-muted-dark hover:text-text dark:hover:text-text-dark underline decoration-dotted focus:outline-none focus:ring-2 focus:ring-accent dark:focus:ring-accent-dark rounded"
              aria-haspopup="dialog"
              aria-controls="changelog-modal"
            ></button>
          </h1>
          <span class="text-xs text-muted dark:text-muted-dark"
            >Drop
            <span class="px-1 py-0.5 rounded bg-code dark:bg-code-dark">eplusout.sql</span>
            to explore variables & meters.</span
          >
        </div>
        <div class="flex flex-nowrap gap-2 overflow-x-auto items-center">
          <label
            class="px-2.5 py-1.5 text-sm shrink-0 border rounded cursor-pointer bg-panel dark:bg-panel-dark border-border dark:border-border-dark hover:bg-panel-2 dark:hover:bg-panel-2-dark"
          >
            <input id="file-input" type="file" accept=".sql,.sqlite,.db" class="hidden" />
            Open eplusout.sql
          </label>
          <button
            id="btn-export"
            type="button"
            disabled
            class="px-3 py-1.5 text-sm rounded-md border disabled:opacity-50 disabled:cursor-not-allowed text-white bg-accent-strong dark:bg-accent-strong-dark border-accent-strong dark:border-accent-strong-dark"
          >
            Export CSV
          </button>
          <button
            id="btn-theme"
            type="button"
            aria-label="Toggle dark mode"
            title="Toggle dark mode"
            class="px-2.5 py-1.5 text-sm shrink-0 border rounded bg-panel dark:bg-panel-dark border-border dark:border-border-dark hover:bg-panel-2 dark:hover:bg-panel-2-dark"
          >
            <!-- Heroicons Sun (outline) shown in light mode -->
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="1.5"
              class="w-5 h-5 dark:hidden"
              aria-hidden="true"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M12 3v2.25M12 18.75V21M4.5 12H2.25M21.75 12H19.5M6.364 6.364l-1.59-1.59M19.227 19.227l-1.59-1.59M6.364 17.636l-1.59 1.59M19.227 4.773l-1.59 1.59M16.5 12a4.5 4.5 0 11-9 0 4.5 4.5 0 019 0z"
              />
            </svg>
            <!-- Heroicons Moon (outline) shown in dark mode -->
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="1.5"
              class="w-5 h-5 hidden dark:inline"
              aria-hidden="true"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M21.752 15.002A9.718 9.718 0 0118 15.75c-5.385 0-9.75-4.365-9.75-9.75 0-1.33.266-2.597.748-3.752A9.753 9.753 0 003 11.25C3 16.635 7.365 21 12.75 21a9.753 9.753 0 009.002-5.998z"
              />
            </svg>
          </button>
          <button
            id="btn-units"
            type="button"
            aria-label="Toggle units"
            title="Toggle SI/IP units"
            class="px-2.5 py-1.5 text-sm shrink-0 border rounded bg-panel dark:bg-panel-dark border-border dark:border-border-dark hover:bg-panel-2 dark:hover:bg-panel-2-dark"
          >
            SI
          </button>
          <button
            id="btn-units-settings"
            type="button"
            aria-label="Unit settings"
            title="Unit settings"
            class="px-2.5 py-1.5 text-sm shrink-0 border rounded bg-panel dark:bg-panel-dark border-border dark:border-border-dark hover:bg-panel-2 dark:hover:bg-panel-2-dark"
          >
            <!-- Heroicons Cog 6 Tooth -->
            <svg
              xmlns="http://www.w3.org/2000/svg"
              viewBox="0 0 24 24"
              fill="none"
              stroke="currentColor"
              stroke-width="1.5"
              class="w-5 h-5"
              aria-hidden="true"
            >
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M9.594 3.94c.09-.542.56-.94 1.11-.94h2.593c.55 0 1.02.398 1.11.94l.213 1.281c.063.374.313.686.645.87.074.04.147.083.22.127.326.196.72.257 1.075.124l1.217-.456a1.125 1.125 0 011.37.49l1.296 2.247a1.125 1.125 0 01-.26 1.431l-1.003.827c-.293.24-.438.613-.431.992a6.759 6.759 0 010 .255c-.007.378.138.75.43.99l1.005.828c.424.35.534.954.26 1.43l-1.298 2.247a1.125 1.125 0 01-1.369.491l-1.217-.456c-.355-.133-.75-.072-1.076.124a6.57 6.57 0 01-.22.128 1.125 1.125 0 00-.645.87l-.213 1.28c-.09.543-.56.941-1.11.941h-2.594c-.55 0-1.02-.398-1.11-.94l-.213-1.281a1.125 1.125 0 00-.645-.87 6.52 6.52 0 01-.22-.128c-.326-.196-.72-.257-1.076-.124l-1.217.456a1.125 1.125 0 01-1.369-.49l-1.297-2.247a1.125 1.125 0 01.26-1.431l1.004-.827c.292-.24.437-.613.43-.992a6.932 6.932 0 010-.255c.007-.378-.138-.75-.43-.99l-1.004-.828a1.125 1.125 0 01-.26-1.43l1.297-2.247a1.125 1.125 0 011.37-.491l1.216.456c.356.133.75.072 1.076-.124.072-.044.146-.087.22-.128.332-.184.582-.496.645-.87l.214-1.281z"
              />
              <path
                stroke-linecap="round"
                stroke-linejoin="round"
                d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"
              />
            </svg>
          </button>
        </div>
      </div>
    </header>

    <main class="grid grid-cols-1 lg:grid-cols-[360px_1fr] gap-3 p-2 sm:p-3 flex-1 overflow-auto">
      <section
        class="flex flex-col rounded-lg border border-border dark:border-border-dark bg-panel dark:bg-panel-dark overflow-hidden min-h-0 order-1 lg:order-none"
      >
        <div
          class="flex justify-between items-center px-3 py-2 border-b border-border dark:border-border-dark bg-panel-2 dark:bg-panel-2-dark"
        >
          <div class="flex items-center gap-2">
            <strong>Signals</strong
            ><span id="meta-count" class="text-muted dark:text-muted-dark"></span>
          </div>
          <!-- Collapse toggle removed -->
        </div>
        <div id="signals-body" class="p-3 flex flex-col gap-2 overflow-auto">
          <div
            id="drop"
            class="border-2 border-dashed rounded p-3 text-center bg-panel dark:bg-panel-dark border-border dark:border-border-dark text-muted dark:text-muted-dark"
          >
            Drag & drop
            <span class="px-1 rounded bg-code dark:bg-code-dark">eplusout.sql</span> here
          </div>
          <input
            type="text"
            id="search"
            placeholder="Search name/group/key/units…"
            disabled
            class="w-full border rounded px-2 py-1 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark"
          />
          <label class="flex items-center gap-2 text-xs text-muted dark:text-muted-dark select-none"
            ><input id="fav-only" type="checkbox" class="h-3.5 w-3.5" />
            <span>Favorites only (double‑click items to ★/☆)</span></label
          >
          <div class="flex gap-2">
            <select
              id="filter-freq"
              disabled
              class="flex-1 border rounded px-2 py-1 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark"
            >
              <option value="">Any frequency</option>
              <option value="Hourly">Hourly</option>
              <option value="Monthly">Monthly</option>
            </select>
            <select
              id="filter-meter"
              disabled
              class="flex-1 border rounded px-2 py-1 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark"
            >
              <option value="">Vars & Meters</option>
              <option value="1">Meters only</option>
              <option value="0">Variables only</option>
            </select>
          </div>
          <select
            id="filter-group"
            disabled
            class="w-full border rounded px-2 py-1 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark"
          >
            <option value="">Any index group</option>
          </select>
          <select
            id="dictionary"
            size="12"
            multiple
            class="w-full border rounded px-2 py-1 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark"
            disabled
          ></select>
          <div class="text-xs text-muted dark:text-muted-dark mt-2">
            Tip: Choose an entry to plot. Hourly → line; Monthly → bars.
          </div>
        </div>
      </section>

      <section
        class="flex flex-col rounded-lg border border-border dark:border-border-dark bg-panel dark:bg-panel-dark overflow-hidden min-h-0 order-2 lg:order-none"
      >
        <div
          class="flex justify-between items-center px-3 py-2 border-b border-border dark:border-border-dark bg-panel-2 dark:bg-panel-2-dark"
        >
          <strong id="series-title">Series</strong
          ><span id="units" class="text-muted dark:text-muted-dark"></span>
        </div>
        <div class="p-3 flex flex-col gap-3 overflow-auto">
          <div id="series-meta" class="relative text-xs text-muted dark:text-muted-dark">
            <div id="series-meta-entries" class="grid grid-cols-[auto_1fr] gap-x-2 pr-10"></div>
          </div>
          <div class="flex items-center justify-between flex-wrap gap-2">
            <div class="flex items-center gap-3 flex-wrap">
              <div
                class="inline-flex rounded border border-border dark:border-border-dark overflow-hidden"
              >
                <button id="view-time" class="px-2 py-1 text-xs bg-panel-2 dark:bg-panel-2-dark">
                  Time Series
                </button>
                <button id="view-ldc" class="px-2 py-1 text-xs">Load Duration</button>
                <button id="view-balance" class="px-2 py-1 text-xs">Load Balance</button>
                <button id="view-scatter" class="px-2 py-1 text-xs">Scatter</button>
              </div>
              <label class="ml-1 text-xs inline-flex items-center gap-1">
                <input id="ldc-normalize" type="checkbox" class="align-middle" />
                Normalize to peak
              </label>
            </div>
            <div
              class="flex items-center gap-2 ml-auto text-sm text-muted dark:text-muted-dark"
              id="toolbar-actions"
            >
              <!-- Zoom always enabled (button removed) -->
              <!-- tariff button will be injected here if present -->
            </div>
          </div>
          <div id="zoom-hint" class="text-xs text-muted dark:text-muted-dark hidden">
            Drag on the mini-map to zoom. Double-tap to reset.
          </div>
          <div id="legend" class="flex flex-wrap gap-2 items-center"></div>
          <div
            id="insights"
            class="rounded-md border border-border dark:border-border-dark bg-panel-2 dark:bg-panel-2-dark p-3 text-sm"
          ></div>
          <div id="kpis" class="grid grid-cols-2 sm:grid-cols-3 xl:grid-cols-6 gap-2"></div>
          <div
            id="chart"
            class="w-full h-[420px] max-[768px]:h-[300px] max-[480px]:h-[220px] relative"
          ></div>
          <div id="stats" class="grid grid-cols-8 gap-2"></div>
        </div>
      </section>
    </main>

    <!-- Changelog Modal -->
    <div
      id="changelog-backdrop"
      class="hidden fixed inset-0 bg-black/40 dark:bg-black/60 backdrop-blur-sm z-40"
    ></div>
    <div
      id="changelog-modal"
      class="hidden fixed z-50 top-[10%] left-1/2 -translate-x-1/2 w-[min(640px,92%)] max-h-[70%] flex flex-col rounded-lg overflow-hidden border border-border dark:border-border-dark bg-panel dark:bg-panel-dark shadow-lg focus:outline-none"
      role="dialog"
      aria-modal="true"
      aria-labelledby="changelog-title"
      tabindex="-1"
    >
      <div
        class="flex items-center justify-between px-4 py-2 border-b border-border dark:border-border-dark bg-panel-2 dark:bg-panel-2-dark rounded-t-lg"
      >
        <h2 id="changelog-title" class="font-semibold text-sm">Changelog</h2>
        <button
          type="button"
          class="p-1 rounded hover:bg-panel-2 dark:hover:bg-panel-2-dark focus:outline-none focus:ring-2 focus:ring-accent dark:focus:ring-accent-dark"
          aria-label="Close"
          onclick="hideChangelog()"
        >
          <svg
            xmlns="http://www.w3.org/2000/svg"
            viewBox="0 0 24 24"
            fill="none"
            stroke="currentColor"
            stroke-width="1.5"
            class="w-5 h-5"
          >
            <path stroke-linecap="round" stroke-linejoin="round" d="M6 18L18 6M6 6l12 12" />
          </svg>
        </button>
      </div>
      <div
        id="changelog-body"
        class="px-4 py-3 overflow-auto text-text dark:text-text-dark text-xs leading-relaxed"
      ></div>
      <div
        class="px-4 py-2 border-t border-border dark:border-border-dark flex justify-end text-[10px] text-muted dark:text-muted-dark"
      >
        <span>Press Esc to close</span>
      </div>
    </div>

    <!-- Units Settings Modal -->
    <div id="units-backdrop" class="fixed inset-0 bg-black/50 hidden z-40"></div>
    <div id="units-modal" class="fixed inset-0 hidden z-50 grid place-items-center p-4">
      <div
        class="w-full max-w-md rounded-xl border border-border dark:border-border-dark bg-panel dark:bg-panel-dark shadow-xl"
      >
        <div
          class="flex items-center justify-between px-4 py-3 border-b border-border dark:border-border-dark"
        >
          <h3 class="text-sm font-semibold">Unit Settings</h3>
          <button
            id="units-close"
            class="p-1 rounded hover:bg-panel-2 dark:hover:bg-panel-2-dark"
            aria-label="Close"
          >
            ✕
          </button>
        </div>
        <div class="p-4 grid gap-4 text-sm">
          <div>
            <div class="text-xs text-muted dark:text-muted-dark mb-1">SI (metric)</div>
            <label class="block mb-1">Energy base unit</label>
            <select
              id="sel-si-energy"
              class="w-full border rounded px-2 py-1 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark"
            >
              <option value="J">J</option>
              <option value="kWh">kWh</option>
              <option value="MWh">MWh</option>
            </select>
            <label class="block mt-3 mb-1">Temperature unit</label>
            <select
              id="sel-si-temp"
              class="w-full border rounded px-2 py-1 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark"
            >
              <option value="C">C</option>
              <option value="K">K</option>
            </select>
          </div>
          <div>
            <div class="text-xs text-muted dark:text-muted-dark mb-1">IP (US customary)</div>
            <label class="block mb-1">Energy base unit</label>
            <select
              id="sel-ip-energy"
              class="w-full border rounded px-2 py-1 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark"
            >
              <option value="BTU">BTU</option>
              <option value="kBTU">kBTU</option>
              <option value="MMBTU">MMBTU</option>
            </select>
            <label class="block mt-3 mb-1">Temperature unit</label>
            <select
              id="sel-ip-temp"
              class="w-full border rounded px-2 py-1 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark"
            >
              <option value="F">F</option>
            </select>
          </div>
          <div>
            <label class="block mb-1">Power base unit (IP)</label>
            <select
              id="sel-ip-power"
              class="w-full border rounded px-2 py-1 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark"
            >
              <option value="Btu/h">Btu/h</option>
              <option value="Tons">Tons</option>
            </select>
            <div class="text-xs text-muted dark:text-muted-dark mt-1">1 Ton = 12,000 Btu/h</div>
          </div>
        </div>
        <div
          class="px-4 py-3 border-t border-border dark:border-border-dark flex justify-end gap-2"
        >
          <button
            id="units-save"
            class="px-3 py-1.5 text-sm rounded text-white bg-accent-strong dark:bg-accent-strong-dark"
          >
            Save
          </button>
        </div>
      </div>
    </div>

    <script>
      const THEME_KEY = 'eplus_theme';
      const UNITS_KEY = 'eplus_units_mode';
      const FAVORITES_KEY = 'eplus_favs';
      const SELECT_KEY = 'eplus_selected_ids';
      const COLLAPSE_KEY = 'eplus_signals_collapsed';
      const TEMP_SI_KEY = 'eplus_temp_si';
      const TEMP_IP_KEY = 'eplus_temp_ip';

      function getPreferredTheme() {
        const s = localStorage.getItem(THEME_KEY);
        return s === 'light' || s === 'dark'
          ? s
          : matchMedia('(prefers-color-scheme: dark)').matches
            ? 'dark'
            : 'light';
      }
      // Inject app version (fallback to hardcoded package.json version if no build replacement)
      (function setAppVersion() {
        try {
          const v = window.__APP_VERSION__ || '0.0.1';
          const el = document.getElementById('app-version');
          if (el) el.textContent = 'v' + v;
        } catch {}
      })();
      // Changelog modal logic
      function escapeHtml(s) {
        return String(s).replace(
          /[&<>"']/g,
          (m) => ({ '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;' })[m],
        );
      }
      function mdToHtml(md) {
        const lines = md.split(/\r?\n/);
        let html = '',
          listOpen = false;
        for (const raw of lines) {
          const line = raw.trimEnd();
          if (!line) {
            if (listOpen) {
              html += '</ul>';
              listOpen = false;
            }
            html += '';
            continue;
          }
          if (line.startsWith('### ')) {
            if (listOpen) {
              html += '</ul>';
              listOpen = false;
            }
            html += '<h3 class="mt-4 text-sm font-semibold">' + escapeHtml(line.slice(4)) + '</h3>';
            continue;
          }
          if (line.startsWith('## ')) {
            if (listOpen) {
              html += '</ul>';
              listOpen = false;
            }
            html +=
              '<h2 class="mt-5 text-base font-semibold">' + escapeHtml(line.slice(3)) + '</h2>';
            continue;
          }
          if (line.startsWith('# ')) {
            if (listOpen) {
              html += '</ul>';
              listOpen = false;
            }
            html += '<h1 class="mt-5 text-lg font-bold">' + escapeHtml(line.slice(2)) + '</h1>';
            continue;
          }
          if (line.startsWith('- ')) {
            if (!listOpen) {
              html += '<ul class="list-disc ml-5 mt-2 space-y-1">';
              listOpen = true;
            }
            html += '<li class="text-xs">' + escapeHtml(line.slice(2)) + '</li>';
            continue;
          }
          // paragraph
          if (listOpen) {
            html += '</ul>';
            listOpen = false;
          }
          html += '<p class="text-xs leading-relaxed mt-2">' + escapeHtml(line) + '</p>';
        }
        if (listOpen) html += '</ul>';
        return html;
      }
      function showChangelog() {
        const backdrop = document.getElementById('changelog-backdrop');
        const modal = document.getElementById('changelog-modal');
        if (!backdrop || !modal) return;
        backdrop.classList.remove('hidden');
        modal.classList.remove('hidden');
        // Load only once
        const body = document.getElementById('changelog-body');
        if (body && !body.dataset.loaded) {
          const embed =
            window.__CHANGELOG_MD__ && typeof window.__CHANGELOG_MD__ === 'string'
              ? window.__CHANGELOG_MD__
              : null;
          const ghOwner = 'samuelduchesne';
          const ghRepo = 'eplusout-dashboard';
          const branch = 'main';
          const ghUrl = `https://raw.githubusercontent.com/${ghOwner}/${ghRepo}/${branch}/CHANGELOG.md`;
          const loadRemote = () =>
            fetch(ghUrl, { cache: 'no-store' }).then((r) => (r.ok ? r.text() : Promise.reject()));
          const loadLocal = () =>
            fetch('CHANGELOG.md').then((r) => (r.ok ? r.text() : Promise.reject()));
          const render = (txt) => {
            body.innerHTML = mdToHtml(txt);
            body.dataset.loaded = '1';
          };
          if (embed) {
            render(embed);
          } else {
            loadRemote()
              .catch(() =>
                location.protocol === 'file:' ? Promise.reject('file-scheme') : loadLocal(),
              )
              .then(render)
              .catch((err) => {
                if (err === 'file-scheme') {
                  body.innerHTML =
                    '<p class="text-xs text-muted dark:text-muted-dark">Open via a local web server to auto-fetch the changelog (e.g. <code>python -m http.server</code>). Or ensure it is embedded at build.</p>';
                } else {
                  // final fallback: show minimal guidance
                  body.innerHTML =
                    '<p class="text-xs text-danger dark:text-danger-dark">Changelog unavailable.</p>';
                }
              });
          }
        }
        modal.focus();
      }
      function hideChangelog() {
        document.getElementById('changelog-backdrop')?.classList.add('hidden');
        document.getElementById('changelog-modal')?.classList.add('hidden');
      }
      document.addEventListener('keydown', (e) => {
        if (e.key === 'Escape') hideChangelog();
      });
      document.addEventListener('click', (e) => {
        if (e.target.id === 'changelog-backdrop') hideChangelog();
      });
      document.getElementById('app-version')?.addEventListener('click', showChangelog);
      function applyTheme(t) {
        // Maintain legacy data-theme attribute (for remaining CSS variable usages)
        document.documentElement.setAttribute('data-theme', t);
        // Ensure Tailwind dark: variants work
        document.documentElement.classList.toggle('dark', t === 'dark');
        const b = document.getElementById('btn-theme');
        if (b) {
          const lbl = t === 'dark' ? 'Switch to light mode' : 'Switch to dark mode';
          b.title = lbl;
          b.setAttribute('aria-label', lbl);
        }
      }
      function toggleTheme() {
        const cur = document.documentElement.getAttribute('data-theme') || 'dark';
        const next = cur === 'dark' ? 'light' : 'dark';
        applyTheme(next);
        localStorage.setItem(THEME_KEY, next);
        refreshChartTheme();
      }
      document.getElementById('btn-theme').addEventListener('click', toggleTheme);
      applyTheme(document.documentElement.getAttribute('data-theme') || getPreferredTheme());
      // Auto-sync with system preference; if user wants to lock a theme they can toggle twice quickly (we'll honor lock if we add a sentinel later)
      try {
        const media = matchMedia('(prefers-color-scheme: dark)');
        const systemListener = (ev) => {
          // If stored value is 'light' or 'dark', still update to keep in sync per user request
          applyTheme(ev.matches ? 'dark' : 'light');
          refreshChartTheme();
        };
        if (media.addEventListener) media.addEventListener('change', systemListener);
        else if (media.addListener) media.addListener(systemListener); // Safari <14 fallback
      } catch {}

      function loadExternalScript(url) {
        return new Promise((res, rej) => {
          if (document.querySelector(`script[data-src="${url}"]`)) return res();
          const s = document.createElement('script');
          s.dataset.src = url;
          s.src = url;
          s.async = true;
          s.onload = () => res();
          s.onerror = () => rej(new Error('Failed to load ' + url));
          document.head.appendChild(s);
        });
      }
      async function ensureD3() {
        if (!window.d3) {
          const url =
            (window.__LIB_URLS__ && window.__LIB_URLS__.d3) ||
            'https://cdn.jsdelivr.net/npm/d3@7/dist/d3.min.js';
          await loadExternalScript(url);
        }
      }
      let SQL;
      async function ensureSql() {
        if (SQL) return SQL;
        if (typeof window.initSqlJs !== 'function') {
          const loader =
            (window.__LIB_URLS__ && window.__LIB_URLS__.sqljs) ||
            'https://cdn.jsdelivr.net/npm/sql.js@1.8.0/dist/sql-wasm.js';
          await loadExternalScript(loader);
        }
        const cfg = window.__SQL_WASM_BASE64__
          ? {
              locateFile: () => 'data:application/wasm;base64,' + window.__SQL_WASM_BASE64__,
            }
          : {
              locateFile: () =>
                (window.__LIB_URLS__ && window.__LIB_URLS__.sqlwasm) ||
                'https://cdn.jsdelivr.net/npm/sql.js@1.8.0/dist/sql-wasm.wasm',
            };
        SQL = await window.initSqlJs(cfg);
        return SQL;
      }

      const $ = (id) => document.getElementById(id);
      // Chart theme colors (replaces legacy cssVar helper)
      function chartColors() {
        const dark = document.documentElement.classList.contains('dark');
        return dark
          ? {
              axis: '#9fb0c3',
              grid: '#223042',
              tooltipBg: 'rgba(20,25,32,0.95)',
              text: '#e6eef7',
              border: '#223042',
              accent: '#2563eb',
              accentStrong: '#1d4ed8',
            }
          : {
              axis: '#334155',
              grid: 'rgb(229 231 235 / 1)',
              tooltipBg: 'rgba(255,255,255,0.98)',
              text: '#0b1220',
              border: '#e2e8f0',
              accent: '#2563eb',
              accentStrong: '#1d4ed8',
            };
      }
      function toObjects(result) {
        if (!result || !result[0]) return [];
        const cols = result[0].columns;
        return result[0].values.map((row) => Object.fromEntries(row.map((v, i) => [cols[i], v])));
      }
      function quantile(sorted, p) {
        if (!sorted.length) return NaN;
        const idx = (sorted.length - 1) * p;
        const lo = Math.floor(idx),
          hi = Math.ceil(idx);
        if (lo === hi) return sorted[lo];
        return sorted[lo] + (sorted[hi] - sorted[lo]) * (idx - lo);
      }
      function computeStats(values) {
        const n = values.length;
        if (!n) return { count: 0 };
        let sum = 0,
          min = Infinity,
          max = -Infinity;
        for (const v of values) {
          sum += v;
          if (v < min) min = v;
          if (v > max) max = v;
        }
        const mean = sum / n;
        const s = [...values].sort((a, b) => a - b);
        return {
          count: n,
          sum,
          min,
          p05: quantile(s, 0.05),
          mean,
          median: quantile(s, 0.5),
          p95: quantile(s, 0.95),
          max,
        };
      }
      function fmt(n) {
        if (n == null || isNaN(n)) return '—';
        const a = Math.abs(n);
        if (a >= 1e6) return (n / 1e6).toFixed(2) + 'M';
        if (a >= 1e3) return (n / 1e3).toFixed(2) + 'k';
        if (a === 0 || a >= 1) return n.toFixed(2);
        return n.toPrecision(3);
      }
      // KPI specific formatting: thousands separators; no decimals for large numbers
      function kpiFmt(n, opts = {}) {
        if (n == null || !isFinite(n)) return '—';
        const abs = Math.abs(n);
        // Allow explicit decimals override
        if (opts.decimals != null) {
          return new Intl.NumberFormat('en-US', {
            minimumFractionDigits: opts.decimals,
            maximumFractionDigits: opts.decimals,
          }).format(n);
        }
        if (abs >= 1000) {
          return new Intl.NumberFormat('en-US', {
            maximumFractionDigits: 0,
          }).format(Math.round(n));
        }
        if (abs >= 100) {
          return new Intl.NumberFormat('en-US', {
            minimumFractionDigits: 1,
            maximumFractionDigits: 1,
          }).format(n);
        }
        return new Intl.NumberFormat('en-US', {
          minimumFractionDigits: 2,
          maximumFractionDigits: 2,
        }).format(n);
      }
      function downloadFile(name, text) {
        const blob = new Blob([text], { type: 'text/plain' });
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = name;
        document.body.appendChild(a);
        a.click();
        URL.revokeObjectURL(a.href);
        a.remove();
      }

      let db,
        dict = [],
        selected = new Map();
      let favs = new Set(JSON.parse(localStorage.getItem(FAVORITES_KEY) || '[]'));
      let zoomEnabled = true; // always on
      let baseFreq = null;
      let viewMode = 'time';
      // scatter pairing state: store chosen x and y series ids (from currently selected list order)
      let scatterPair = null; // {x:id,y:id}
      let scatterShowRegression = true;
      // Preserve current hourly x-domain across redraws (zoom + resize)
      let currentXDomain = null;

      let isIP = localStorage.getItem(UNITS_KEY) === 'IP' ? true : false;
      const btnUnits = $('btn-units');
      if (btnUnits) {
        btnUnits.textContent = isIP ? 'IP' : 'SI';
        btnUnits.addEventListener('click', () => {
          isIP = !isIP;
          btnUnits.textContent = isIP ? 'IP' : 'SI';
          localStorage.setItem(UNITS_KEY, isIP ? 'IP' : 'SI');
          renderAll();
        });
      }

      // Units preferences + modal wiring
      const ENERGY_SI_KEY = 'eplus_energy_unit_si';
      const ENERGY_IP_KEY = 'eplus_energy_unit_ip';
      const POWER_IP_KEY = 'eplus_power_unit_ip';
      let prefEnergySI = localStorage.getItem(ENERGY_SI_KEY) || 'J';
      let prefEnergyIP = localStorage.getItem(ENERGY_IP_KEY) || 'BTU';
      let prefPowerIP = localStorage.getItem(POWER_IP_KEY) || 'Btu/h';

      const btnUnitsSettings = $('btn-units-settings');
      const unitsModal = $('units-modal');
      const unitsBackdrop = $('units-backdrop');
      const unitsClose = $('units-close');
      const unitsSave = $('units-save');
      const selSiEnergy = $('sel-si-energy');
      const selIpEnergy = $('sel-ip-energy');
      const selIpPower = $('sel-ip-power');
      // Temperature prefs
      let prefTempSI = localStorage.getItem(TEMP_SI_KEY) || 'C'; // C or K
      let prefTempIP = localStorage.getItem(TEMP_IP_KEY) || 'F'; // F (future: R)

      function showUnits() {
        selSiEnergy.value = prefEnergySI;
        selIpEnergy.value = prefEnergyIP;
        selIpPower.value = prefPowerIP;
        const siTempSel = $('sel-si-temp');
        const ipTempSel = $('sel-ip-temp');
        if (siTempSel) siTempSel.value = prefTempSI;
        if (ipTempSel) ipTempSel.value = prefTempIP;
        unitsModal.classList.remove('hidden');
        unitsBackdrop.classList.remove('hidden');
      }
      function hideUnits() {
        unitsModal.classList.add('hidden');
        unitsBackdrop.classList.add('hidden');
      }
      btnUnitsSettings?.addEventListener('click', showUnits);
      unitsClose?.addEventListener('click', hideUnits);
      unitsBackdrop?.addEventListener('click', hideUnits);
      unitsSave?.addEventListener('click', () => {
        prefEnergySI = selSiEnergy.value;
        prefEnergyIP = selIpEnergy.value;
        prefPowerIP = selIpPower.value;
        const siTempSel = $('sel-si-temp');
        const ipTempSel = $('sel-ip-temp');
        if (siTempSel) prefTempSI = siTempSel.value;
        if (ipTempSel) prefTempIP = ipTempSel.value;
        localStorage.setItem(ENERGY_SI_KEY, prefEnergySI);
        localStorage.setItem(ENERGY_IP_KEY, prefEnergyIP);
        localStorage.setItem(POWER_IP_KEY, prefPowerIP);
        localStorage.setItem(TEMP_SI_KEY, prefTempSI);
        localStorage.setItem(TEMP_IP_KEY, prefTempIP);
        hideUnits();
        renderAll();
      });

      function unitKind(units) {
        if (!units) return 'other';
        const u = String(units).toLowerCase();
        if (
          u.includes('wh') ||
          u.includes('joule') ||
          u === 'j' ||
          u.includes('kwh') ||
          u.includes('mwh')
        )
          return 'energy';
        if (
          u.includes('btu/h') ||
          u.includes('btuh') ||
          /\bw(?!h)\b/.test(u) ||
          u.includes('watt') ||
          u.includes('ton')
        )
          return 'power';
        if (
          u === 'c' ||
          u.includes('celsius') ||
          u === 'k' ||
          u.includes('kelvin') ||
          u === 'f' ||
          u.includes('fahrenheit')
        )
          return 'temperature';
        return 'other';
      }
      function toJoules(value, units) {
        const u = String(units || '').toLowerCase();
        if (u.includes('mwh')) return value * 3.6e9;
        if (u.includes('kwh')) return value * 3.6e6;
        if (u.includes('wh')) return value * 3600;
        if (u.includes('joule') || u === 'j') return value;
        return null;
      }

      // NOTE: Avoid capturing a hoisted previous convertUnits; identity fallbacks prevent recursion.
      const __orig_convertUnits = (v) => v;
      const __orig_convertUnitLabel = (u) => u || '';

      function convertUnits(value, units) {
        if (value == null || !isFinite(value)) return value;
        if (!units) return value;
        const kind = unitKind(units);
        if (isIP) {
          const u = String(units).toLowerCase();
          if (u === 'c' || u.includes('celsius')) return (value * 9) / 5 + 32;
          if (kind === 'energy') {
            let J = toJoules(value, units);
            if (J == null) J = value;
            let btu = J / 1055.06;
            if (prefEnergyIP === 'kBTU') return btu / 1e3;
            if (prefEnergyIP === 'MMBTU') return btu / 1e6;
            return btu;
          }
          if (kind === 'power') {
            let v = value;
            const ul = String(units).toLowerCase();
            if (ul.includes('w') && !ul.includes('wh')) v = value * 3.412141633;
            if (prefPowerIP === 'Tons') return v / 12000;
            return v;
          }
          if (kind === 'temperature') {
            // Incoming likely C; already converted above. If preference IP temp differs (future), handle here.
            if (prefTempIP === 'F') {
              if (/c|celsius/.test(String(units).toLowerCase())) return (value * 9) / 5 + 32;
              if (/k|kelvin/.test(String(units).toLowerCase()))
                return ((value - 273.15) * 9) / 5 + 32;
            }
            return value;
          }
          return __orig_convertUnits(value, units);
        } else {
          if (kind === 'energy') {
            let J = toJoules(value, units);
            if (J == null) J = value;
            if (prefEnergySI === 'kWh') return J / 3.6e6;
            if (prefEnergySI === 'MWh') return J / 3.6e9;
            return J;
          }
          if (kind === 'temperature') {
            const ul = String(units).toLowerCase();
            let cVal;
            if (ul === 'c' || ul.includes('celsius')) cVal = value;
            else if (ul === 'k' || ul.includes('kelvin')) cVal = value - 273.15;
            else if (ul === 'f' || ul.includes('fahrenheit')) cVal = ((value - 32) * 5) / 9;
            else cVal = value;
            if (prefTempSI === 'K') return cVal + 273.15;
            return cVal; // C
          }
          return __orig_convertUnits(value, units);
        }
      }
      function convertUnitLabel(units) {
        if (!units) return units || '';
        const kind = unitKind(units);
        if (isIP) {
          const u = String(units).toLowerCase();
          if (u === 'c' || u.includes('celsius')) return 'F';
          if (kind === 'energy') return prefEnergyIP;
          if (kind === 'power') return prefPowerIP === 'Tons' ? 'tons' : 'Btu/h';
          if (kind === 'temperature') return prefTempIP;
          return __orig_convertUnitLabel(units);
        } else {
          if (kind === 'energy') return prefEnergySI;
          if (kind === 'temperature') return prefTempSI;
          return __orig_convertUnitLabel(units);
        }
      }

      // Helper: label for opposite unit system (only energy/power for now)
      function convertUnitLabelOpposite(units) {
        if (!units) return '';
        const kind = unitKind(units);
        if (isIP) {
          // left IP, right SI
          if (kind === 'energy') return prefEnergySI;
          if (kind === 'power') return 'W';
          if (kind === 'temperature') return prefTempSI;
        } else {
          // left SI, right IP
          if (kind === 'energy') return prefEnergyIP;
          if (kind === 'power') return prefPowerIP === 'Tons' ? 'tons' : 'Btu/h';
          if (kind === 'temperature') return prefTempIP;
        }
        return '';
      }
      // Convert a displayed tick value (already in current system) to opposite system.
      function convertDisplayedToOpposite(v, origUnits) {
        if (!isFinite(v)) return v;
        const kind = unitKind(origUnits);
        if (kind === 'energy') {
          if (isIP) {
            // IP -> SI
            let J; // build J from current displayed IP unit
            if (prefEnergyIP === 'BTU') J = v * 1055.06;
            else if (prefEnergyIP === 'kBTU') J = v * 1000 * 1055.06;
            else if (prefEnergyIP === 'MMBTU') J = v * 1e6 * 1055.06;
            else J = v * 1055.06; // fallback
            if (prefEnergySI === 'J') return J;
            if (prefEnergySI === 'kWh') return J / 3.6e6;
            if (prefEnergySI === 'MWh') return J / 3.6e9;
            return J;
          } else {
            // SI -> IP
            let J;
            if (prefEnergySI === 'J') J = v;
            else if (prefEnergySI === 'kWh') J = v * 3.6e6;
            else if (prefEnergySI === 'MWh') J = v * 3.6e9;
            else J = v;
            const BTU = J / 1055.06;
            if (prefEnergyIP === 'BTU') return BTU;
            if (prefEnergyIP === 'kBTU') return BTU / 1000;
            if (prefEnergyIP === 'MMBTU') return BTU / 1e6;
            return BTU;
          }
        }
        if (kind === 'power') {
          if (isIP) {
            // IP -> SI (W)
            let Btuh;
            if (prefPowerIP === 'Tons') Btuh = v * 12000;
            else Btuh = v; // v is in Btu/h already
            const W = Btuh * 0.29307107; // 1 Btu/h =0.29307107 W
            return W;
          } else {
            // SI -> IP
            const W = v;
            if (prefPowerIP === 'Tons') return W / 0.29307107 / 12000; // W -> Btu/h -> tons
            return W / 0.29307107; // Btu/h
          }
        }
        if (kind === 'temperature') {
          if (isIP) {
            // IP displayed -> SI opposite prefer C or K
            let c;
            if (prefTempIP === 'F') c = ((v - 32) * 5) / 9;
            else c = v; // future other scales
            if (prefTempSI === 'K') return c + 273.15;
            return c;
          } else {
            // SI displayed -> IP opposite (F)
            let c;
            if (prefTempSI === 'K') c = v - 273.15;
            else c = v;
            if (prefTempIP === 'F') return (c * 9) / 5 + 32;
            return c;
          }
        }
        return v; // other kinds not converted
      }

      function refreshChartTheme() {
        if (selected.size === 0) return;
        renderAll();
      }
      async function readDbFile(file) {
        const SQLMod = await ensureSql();
        const u8 = new Uint8Array(await file.arrayBuffer());
        db = new SQLMod.Database(u8);
        return db;
      }
      function queryDictionary() {
        const sql = `
      SELECT ReportDataDictionaryIndex AS id, IsMeter, Type, IndexGroup, KeyValue AS key,
             Name, ReportingFrequency AS freq, Units
      FROM ReportDataDictionary
      WHERE ReportingFrequency IN ('Hourly','Monthly')
      ORDER BY IsMeter DESC, IndexGroup, Name, key;`;
        dict = toObjects(db.exec(sql));
        // Invalidate load balance cache (new DB or changed dict)
        __loadBalanceCache = null;
        return dict;
      }
      function queryTimeSeries(dictId) {
        const stmt = db.prepare(`
      SELECT rd.Value AS value, t.EnvironmentPeriodIndex AS env, t.SimulationDays AS sday,
             t.Month AS month, t.Day AS day, t.Hour AS hour, t.Minute AS minute,
             t.IntervalType AS interval, t.TimeIndex AS tindex
      FROM ReportData rd JOIN Time t ON t.TimeIndex = rd.TimeIndex
      WHERE rd.ReportDataDictionaryIndex = ?
      ORDER BY t.TimeIndex;`);
        stmt.bind([dictId]);
        const rows = [];
        while (stmt.step()) rows.push(stmt.getAsObject());
        stmt.free();
        return rows;
      }

      function timeLabel(r) {
        const hh = String(r.hour ?? 0).padStart(2, '0');
        const mm = String(r.minute ?? 0).padStart(2, '0');
        const md = `${String(r.month || 1).padStart(2, '0')}/${String(r.day || 1).padStart(
          2,
          '0',
        )}`;
        return `Env ${r.env} — ${md} ${hh}:${mm}`;
      }
      function toHourlyPoints(rows) {
        const year = 2000;
        return rows.map((r) => ({
          x: Date.UTC(
            year + (r.env || 0) - 1,
            (r.month || 1) - 1,
            r.day || 1,
            r.hour || 0,
            r.minute || 0,
          ),
          y: Number(r.value),
          label: timeLabel(r),
        }));
      }
      function toMonthlyPoints(rows) {
        return rows.map((r) => ({
          xLabel: `E${r.env}-M${String(r.month || 1).padStart(2, '0')}`,
          y: Number(r.value),
        }));
      }

      function exportCSV(seriesMap) {
        const header =
          baseFreq === 'Hourly'
            ? ['datetime_utc', 'value', 'series_id']
            : ['label', 'value', 'series_id'];
        const rows = [header.join(',')];
        seriesMap.forEach((v, id) => {
          const series = v.points;
          const units = v.meta.Units || '';
          for (const d of series) {
            const val = convertUnits(d.y, units);
            const x = Number.isFinite(d.x) ? new Date(d.x).toISOString() : d.xLabel || '';
            rows.push(`${JSON.stringify(x)},${val},${id}`);
          }
        });
        return rows.join('\n');
      }

      // Chart palette derived from Tailwind color tokens (light theme values defined in tailwind.config.js)
      const palette = [
        '#2563eb', // chart-1 / accent
        '#16a34a', // chart-2
        '#9333ea', // chart-3
        '#dc2626', // chart-4
        '#f59e0b', // chart-5
        '#0891b2', // chart-6
        '#64748b', // chart-7
        '#4f46e5', // chart-8
        '#059669', // chart-9
        '#d946ef', // chart-10
      ];

      // Cache for load balance aggregated monthly category data (raw Joules)
      // Invalidated whenever the dictionary is re-queried (new database loaded)
      let __loadBalanceCache = null; // { monthLabels, catTotals, missing }

      let __rendering = false;
      function renderAll() {
        if (__rendering) return; // prevent re-entrant recursive calls
        __rendering = true;
        try {
          const metaEl = $('series-meta-entries');
          const unitsEl = $('units');
          const titleEl = $('series-title');
          const metas = [...selected.values()].map((v) => v.meta);
          const normalizeFlag = viewMode === 'time' && $('ldc-normalize')?.checked === true;
          titleEl.textContent = metas.length ? `${baseFreq} • ${metas.length} series` : 'Series';
          const consistentUnits = metas.every((m) => m.Units === metas[0]?.Units);
          unitsEl.textContent = metas.length
            ? consistentUnits
              ? convertUnitLabel(metas[0]?.Units || '')
              : '(mixed units)'
            : '';
          metaEl.innerHTML = metas
            .map(
              (m) =>
                `<span class='text-muted dark:text-muted-dark'>${
                  m.IsMeter ? 'Meter' : 'Variable'
                }:</span><span>${escapeHtml(m.Name)}${
                  m.key ? ` (${escapeHtml(m.key)})` : ''
                }</span>`,
            )
            .join('');
          const visibleEntries = [...selected.entries()].filter(([, v]) => v.visible !== false);
          const series = visibleEntries.map(([id, v], i) => ({
            id,
            meta: v.meta,
            color: palette[i % palette.length],
            points: v.points,
            visible: v.visible !== false,
          }));
          if (viewMode === 'ldc') {
            if (baseFreq !== 'Hourly') {
              $('legend').innerHTML = '';
              $('chart').innerHTML = '';
              $('insights').innerHTML = 'Load duration curves require Hourly data.';
              $('units').textContent = '(n/a)';
            } else {
              renderLDC(series);
            }
          } else if (viewMode === 'balance') {
            // Show loading state while load balance aggregates (can be heavy on first run)
            const chartEl = $('chart');
            if (chartEl) {
              chartEl.innerHTML = `<div id='lb-loading' class='absolute inset-0 flex flex-col gap-3 items-center justify-center text-center bg-panel/40 dark:bg-panel-dark/40 backdrop-blur-sm'>
  <div class='w-8 h-8 border-2 border-accent dark:border-accent-dark border-t-transparent rounded-full animate-spin' aria-hidden='true'></div>
  <div class='text-[11px] px-3 py-1.5 rounded bg-panel-2 dark:bg-panel-2-dark border border-border dark:border-border-dark shadow-md text-muted dark:text-muted-dark' role='status' aria-live='polite'>Loading load balance…</div>
</div>`;
            }
            // Allow at least one paint cycle before heavy work:
            // rAF fires before paint, so a single rAF still blocks showing the spinner.
            // Use setTimeout (or a double rAF) to yield so the spinner renders first.
            requestAnimationFrame(() =>
              setTimeout(() => {
                renderLoadBalance(series).finally(() => {
                  const l = document.getElementById('lb-loading');
                  if (l && l.parentElement === chartEl) l.remove();
                });
              }, 0),
            );
          } else {
            if (viewMode === 'scatter') {
              renderScatter(series);
            } else {
              renderChart(series, { normalize: normalizeFlag });
              renderInsights(series);
              renderKPIs(series);
              if (normalizeFlag && metas.length) {
                unitsEl.textContent = '%';
              }
            }
          }
          renderStats(series); // always refresh stats (even if empty)
          const has = selected.size > 0;
          const b = $('btn-export');
          if (b) b.disabled = !has;
        } finally {
          __rendering = false;
        }
      }

      async function handleSelectionChange() {
        try {
          const selEl = $('dictionary');
          const chosen = [...selEl.selectedOptions].map((o) => Number(o.value));
          localStorage.setItem(SELECT_KEY, JSON.stringify(chosen));
          if (chosen.length === 0) {
            selected.clear();
            baseFreq = null;
            currentXDomain = null;
            renderAll();
            return;
          }
          const first = dict.find((d) => d.id === chosen[0]);
          const newFreq = first?.freq || 'Hourly';
          if (newFreq !== baseFreq) currentXDomain = null;
          baseFreq = newFreq;
          for (const id of chosen) {
            const meta = dict.find((d) => d.id === id);
            if (!meta || meta.freq !== baseFreq) continue;
            if (!selected.has(id)) {
              const rows = queryTimeSeries(id);
              const pts = baseFreq === 'Hourly' ? toHourlyPoints(rows) : toMonthlyPoints(rows);
              selected.set(id, { meta, points: pts, visible: true });
            }
          }
          for (const id of [...selected.keys()]) {
            if (!chosen.includes(id)) selected.delete(id);
          }
          renderAll();
        } catch (e) {
          console.error('Selection change failed', e);
        }
      }

      function renderInsights(series) {
        const el = $('insights');
        if (series.length === 0) {
          el.textContent = '';
          return;
        }
        const lines = series.map((s) => {
          const vals = s.points.map((p) => convertUnits(p.y, s.meta.Units));
          const st = computeStats(vals);
          const maxIdx = vals.indexOf(Math.max(...vals));
          const when = s.points[maxIdx];
          const whenTxt = when?.label || when?.xLabel || '';
          return `<span style='color:${s.color}'>${escapeHtml(s.meta.Name)}</span>: peak ${fmt(
            st.max,
          )} at ${escapeHtml(String(whenTxt))}`;
        });
        el.innerHTML = lines.join('<br/>');
      }

      // ================= KPIs & Stats =================
      let buildingAreaCache = null; // in m2
      async function getBuildingArea() {
        if (buildingAreaCache != null) return buildingAreaCache;
        try {
          // Preferred direct query (AnnualBuildingUtilityPerformanceSummary)
          try {
            const direct = db.exec(`SELECT Value AS total_building_area_m2
              FROM TabularDataWithStrings
              WHERE ReportName='AnnualBuildingUtilityPerformanceSummary'
                AND TableName='Building Area'
                AND RowName='Total Building Area'
                AND ColumnName='Area'
                AND ReportForString LIKE 'Entire Facility%'
              LIMIT 1;`);
            const val = direct[0]?.values?.[0]?.[0];
            if (val != null) {
              const num = Number(val);
              if (isFinite(num) && num > 0) {
                buildingAreaCache = num;
                return num;
              }
            }
          } catch {}
          // Detect available columns (older sql schemas may differ)
          let hasRow = true,
            hasCol = true;
          try {
            const info = db.exec('PRAGMA table_info(TabularData)');
            const cols = new Set((info[0]?.values || []).map((r) => String(r[1]).toLowerCase()));
            hasRow = cols.has('rowname');
            hasCol = cols.has('columnname');
          } catch {}
          let q1 = [];
          if (hasRow && hasCol) {
            try {
              q1 = db.exec(
                `SELECT Value FROM TabularData WHERE (LOWER(RowName) LIKE '%net conditioned building area%' OR LOWER(RowName) LIKE '%total building area%' OR LOWER(RowName) LIKE '%building area%') AND (LOWER(ColumnName)='area' OR LOWER(ColumnName) LIKE '%m2%') LIMIT 1;`,
              );
            } catch {}
          }
          if (q1[0]?.values?.[0]?.[0]) {
            const v = Number(q1[0].values[0][0]);
            if (isFinite(v) && v > 0) {
              buildingAreaCache = v;
              return v;
            }
          }
          // Fallback parse strings table if RowName exists
          if (hasRow) {
            let q2 = [];
            try {
              q2 = db.exec(
                `SELECT Value FROM TabularDataWithStrings WHERE (LOWER(RowName) LIKE '%net conditioned building area%' OR LOWER(RowName) LIKE '%total building area%' OR LOWER(RowName) LIKE '%building area%') LIMIT 10;`,
              );
            } catch {}
            if (q2[0]) {
              for (const row of q2[0].values) {
                const m = /([0-9]+(?:\.[0-9]+)?)/.exec(row[0]);
                if (m) {
                  const v = Number(m[1]);
                  if (isFinite(v) && v > 0) {
                    buildingAreaCache = v;
                    return v;
                  }
                }
              }
            }
          }
        } catch (e) {
          console.warn('Area query failed', e);
        }
        buildingAreaCache = null;
        return null;
      }

      function annualEnergyFromPoints(points, units) {
        if (!points || !points.length) return null; // Expect energy values per interval (Hourly or Monthly)
        // Convert each y (raw) to Joules (if convertible) else attempt numeric sum
        let totalJ = 0;
        let hasJ = true;
        for (const p of points) {
          const raw = p.y;
          const J = toJoules(raw, units);
          if (J == null) {
            hasJ = false;
            break;
          }
          totalJ += J;
        }
        if (hasJ) return { J: totalJ };
        // fallback treat value already in preferred converted units
        const vals = points.map((p) => convertUnits(p.y, units)).filter((v) => isFinite(v));
        return {
          value: vals.reduce((a, b) => a + b, 0),
          units: convertUnitLabel(units),
        };
      }

      function loadFactor(points, units) {
        if (baseFreq !== 'Hourly' || !points.length) return null;
        const vals = points.map((p) => convertUnits(p.y, units));
        const st = computeStats(vals);
        if (!st.max || st.max === 0) return null;
        return st.mean / st.max;
      }

      async function renderKPIs(series) {
        const el = $('kpis');
        el.innerHTML = '';
        if (!series.length) return;
        const primary = series[0];
        const isMeter = primary.meta.IsMeter == 1;
        const kpiItems = []; // {title,value,desc}
        if (isMeter) {
          const annual = annualEnergyFromPoints(primary.points, primary.meta.Units);
          if (annual) {
            let displayVal = '—',
              label = 'Annual Energy';
            if (annual.J != null) {
              // convert to current preferred energy unit
              let val;
              let unitLbl;
              if (isIP) {
                const kWh = annual.J / 3.6e6; // always compute kWh for cost/EUI
                // Convert to chosen IP energy unit by converting J -> chosen label through existing convertUnits path
                val = convertUnits(annual.J, 'J');
                unitLbl = convertUnitLabel('J');
                displayVal = `${kpiFmt(val)} ${unitLbl}`;
              } else {
                val = convertUnits(annual.J, 'J');
                unitLbl = convertUnitLabel('J');
                displayVal = `${kpiFmt(val)} ${unitLbl}`;
              }
              kpiItems.push({
                title: label,
                value: displayVal,
                desc: 'Total annual energy summed over all intervals for the selected meter.',
              });
              // EUI if area available
              const area = await getBuildingArea();
              if (area) {
                const kWh = annual.J / 3.6e6;
                let euiVal, euiUnits;
                if (isIP) {
                  // kBtu/ft2 or MMBtu/ft2 depending on energy unit selection
                  const ft2 = area * 10.7639;
                  const kBtu = kWh * 3.412141633;
                  if (prefEnergyIP === 'MMBTU') {
                    euiVal = kBtu / 1000 / ft2;
                    euiUnits = 'MMBtu/ft²';
                  } else if (prefEnergyIP === 'kBTU') {
                    euiVal = kBtu / ft2;
                    euiUnits = 'kBtu/ft²';
                  } else {
                    euiVal = (kBtu / ft2) * 1000;
                    euiUnits = 'Btu/ft²';
                  }
                } else {
                  const m2 = area;
                  const kWhVal = kWh;
                  if (prefEnergySI === 'MWh') {
                    euiVal = kWhVal / 1000 / m2;
                    euiUnits = 'MWh/m²';
                  } else if (prefEnergySI === 'kWh') {
                    euiVal = kWhVal / m2;
                    euiUnits = 'kWh/m²';
                  } else {
                    // J
                    euiVal = annual.J / m2;
                    euiUnits = 'J/m²';
                  }
                }
                kpiItems.push({
                  title: 'EUI',
                  value: `${kpiFmt(euiVal)} ${euiUnits}`,
                  desc: 'Energy Use Intensity: annual energy divided by building floor area.',
                });
              } else {
                kpiItems.push({
                  title: 'EUI',
                  value: 'Area?',
                  desc: 'Energy Use Intensity. Floor area not found in tabular output.',
                });
              }
            } else if (annual.value != null) {
              kpiItems.push({
                title: label,
                value: `${kpiFmt(annual.value)} ${annual.units || ''}`,
                desc: 'Total annual energy summed over all intervals for the selected meter.',
              });
            }
          }
        }
        // Peak demand & timestamp already computed in insights; replicate for first series
        const vals = primary.points.map((p) => convertUnits(p.y, primary.meta.Units));
        const st = computeStats(vals);
        if (isFinite(st.max)) {
          const idx = vals.indexOf(st.max);
          const when = primary.points[idx];
          const whenTxt = when?.label || when?.xLabel || '';
          kpiItems.push({
            title: 'Peak',
            value: `${kpiFmt(st.max)} ${convertUnitLabel(primary.meta.Units)}
<span class='block text-[10px] text-muted dark:text-muted-dark truncate'>${escapeHtml(
              whenTxt,
            )}</span>`,
            desc: 'Maximum interval value and when it occurred.',
          });
        }
        const lf = loadFactor(primary.points, primary.meta.Units);
        if (lf) {
          kpiItems.push({
            title: 'Load Factor',
            value: (lf * 100).toFixed(1) + '%',
            desc: 'Average / peak over the Weather Run Period (Hourly data only).',
          });
        }
        // Tariff cost (energy + demand) if annual energy computed and hourly
        if (baseFreq === 'Hourly' && isMeter) {
          const cost = computeTariffCost(primary);
          if (cost) {
            kpiItems.push({
              title: 'Cost (est.)',
              value: `$${kpiFmt(
                cost.total,
              )}<span class='block text-[10px] text-muted dark:text-muted-dark'>E:$${kpiFmt(
                cost.energy,
              )} D:$${kpiFmt(cost.demand)}</span>`,
              desc: 'Simple cost estimate: flat $/kWh energy plus monthly peak demand charges.',
            });
          }
        }
        // Energy balance (only if facility meter)
        if (/electricity:facility/i.test(primary.meta.Name || '')) {
          const eb = await computeEnergyBalance('Electricity');
          if (eb) {
            const cls =
              Math.abs(eb.residualPct) > 5
                ? 'text-danger dark:text-danger-dark font-semibold'
                : 'text-muted dark:text-muted-dark';
            kpiItems.push({
              title: 'Elec Balance',
              value: `<span class='${cls}'>${kpiFmt(eb.residualPct, {
                decimals: 1,
              })}%</span>`,
              desc: 'Residual between Electricity:Facility and the sum of end-use electricity meters.',
            });
          }
        }
        // Render
        el.innerHTML = kpiItems
          .map(
            (
              k,
            ) => `<div class="relative group p-2 rounded-md border border-border dark:border-border-dark bg-panel-2 dark:bg-panel-2-dark flex flex-col min-w-[110px]" data-tip="${escapeHtml(
              k.desc || '',
            )}">
            <span class="flex items-center justify-between gap-1">
              <span class="text-[10px] uppercase tracking-wide text-muted dark:text-muted-dark">${escapeHtml(
                k.title,
              )}</span>
              <button type="button" class="kpi-help text-[10px] w-4 h-4 leading-none inline-flex items-center justify-center border border-border dark:border-border-dark rounded cursor-help" aria-label="Info" tabindex="0">?</button>
            </span>
            <span class="text-sm leading-tight mt-0.5">${k.value}</span>
          </div>`,
          )
          .join('');
        attachKpiTooltips();
      }

      // Tooltip logic for KPI cards (hover + tap)
      let kpiTooltipEl = null;
      let kpiActiveBtn = null;
      function ensureKpiTooltip() {
        if (!kpiTooltipEl) {
          kpiTooltipEl = document.createElement('div');
          kpiTooltipEl.id = 'kpi-tooltip';
          kpiTooltipEl.className =
            'pointer-events-none text-xs max-w-[200px] z-40 fixed hidden px-2.5 py-1.5 rounded-md border border-border dark:border-border-dark bg-panel dark:bg-panel-dark shadow-lg';
          document.body.appendChild(kpiTooltipEl);
        }
        return kpiTooltipEl;
      }
      function showKpiTooltip(target, text) {
        const tip = ensureKpiTooltip();
        tip.innerHTML = escapeHtml(text);
        const rect = target.getBoundingClientRect();
        const top = rect.top - 8;
        const left = Math.min(window.innerWidth - 220, rect.left);
        tip.style.top = (top < 8 ? rect.bottom + 8 : top) + 'px';
        tip.style.left = left + 'px';
        tip.classList.remove('hidden');
      }
      function hideKpiTooltip() {
        if (kpiTooltipEl) kpiTooltipEl.classList.add('hidden');
        kpiActiveBtn = null;
      }
      function attachKpiTooltips() {
        const helps = document.querySelectorAll('#kpis .kpi-help, #tariff-pop .kpi-help');
        helps.forEach((btn) => {
          const parent = btn.closest('[data-tip]');
          const text = parent?.getAttribute('data-tip') || '';
          const enter = () => {
            if (!text) return;
            showKpiTooltip(btn, text);
          };
          const leave = (e) => {
            if (e.type === 'mouseleave' && kpiActiveBtn === btn) return;
            if (!kpiActiveBtn) hideKpiTooltip();
          };
          btn.addEventListener('mouseenter', enter);
          btn.addEventListener('focus', enter);
          btn.addEventListener('mouseleave', leave);
          btn.addEventListener('blur', () => {
            if (kpiActiveBtn !== btn) hideKpiTooltip();
          });
          btn.addEventListener('click', (e) => {
            e.stopPropagation();
            if (kpiActiveBtn === btn) {
              kpiActiveBtn = null;
              hideKpiTooltip();
            } else {
              kpiActiveBtn = btn;
              showKpiTooltip(btn, text);
            }
          });
        });
        document.addEventListener('click', (e) => {
          if (kpiActiveBtn && !e.target.closest('#kpis') && !e.target.closest('#tariff-pop'))
            hideKpiTooltip();
        });
        window.addEventListener(
          'scroll',
          () => {
            if (kpiActiveBtn) hideKpiTooltip();
          },
          true,
        );
      }

      function renderStats(series) {
        const el = $('stats');
        if (!el) return;
        if (!series.length) {
          el.innerHTML = '';
          return;
        }
        // Build header row + one row per series
        const cols = ['Series', 'Min', 'P05', 'Mean', 'Median', 'P95', 'Max'];
        const rows = [
          `<div class='contents'>${cols
            .map(
              (c) =>
                `<div class="text-[10px] font-semibold uppercase tracking-wide text-muted dark:text-muted-dark">${c}</div>`,
            )
            .join('')}</div>`,
        ];
        series.forEach((s) => {
          const vals = s.points.map((p) => convertUnits(p.y, s.meta.Units));
          const st = computeStats(vals);
          rows.push(`<div class='contents'>
          <div class='text-[10px] truncate' style='color:${s.color}'>${escapeHtml(
            s.meta.Name,
          )}</div>
          <div class='text-[11px]'>${fmt(st.min)}</div>
          <div class='text-[11px]'>${fmt(st.p05)}</div>
          <div class='text-[11px]'>${fmt(st.mean)}</div>
          <div class='text-[11px]'>${fmt(st.median)}</div>
          <div class='text-[11px]'>${fmt(st.p95)}</div>
          <div class='text-[11px]'>${fmt(st.max)}</div>
        </div>`);
        });
        el.className = 'grid gap-x-3 gap-y-1 items-center'; // responsive grid auto-flow
        el.style.gridTemplateColumns = 'repeat(7,minmax(0,1fr))';
        el.innerHTML = rows.join('');
      }

      // Energy Balance
      const energyBalanceCache = {};
      async function computeEnergyBalance(kind) {
        // kind e.g. 'Electricity'
        const key = kind.toLowerCase();
        if (energyBalanceCache[key]) return energyBalanceCache[key];
        try {
          const names = [
            'Facility',
            'Heating',
            'Cooling',
            'InteriorLights',
            'ExteriorLights',
            'InteriorEquipment',
            'ExteriorEquipment',
            'Fans',
            'Pumps',
            'HeatRejection',
            'Humidification',
            'HeatRecovery',
            'WaterSystems',
            'Refrigeration',
            'Cogeneration',
          ];
          function findDict(name) {
            return dict.find((d) => d.Name === `${kind}:${name}` && d.freq === 'Monthly');
          }
          const fac = findDict('Facility');
          if (!fac) return null;
          const rowsFacility = queryTimeSeries(fac.id);
          const totalFac = rowsFacility.reduce((a, r) => a + Number(r.value || 0), 0);
          let sumComponents = 0;
          names
            .filter((n) => n !== 'Facility')
            .forEach((n) => {
              const m = findDict(n);
              if (m) {
                const rs = queryTimeSeries(m.id);
                const s = rs.reduce((a, r) => a + Number(r.value || 0), 0);
                sumComponents += s;
              }
            });
          if (totalFac <= 0) return null;
          const residual = totalFac - sumComponents;
          const residualPct = (residual / totalFac) * 100;
          const out = {
            facilityJ: totalFac,
            componentsJ: sumComponents,
            residualJ: residual,
            residualPct,
          };
          energyBalanceCache[key] = out;
          return out;
        } catch (e) {
          console.warn('Energy balance failed', e);
          return null;
        }
      }

      // Tariff simple cost model
      const TARIFF_ENERGY_KEY = 'eplus_tariff_energy_rate'; // legacy single
      const TARIFF_ENERGY_KEY_ELEC = 'eplus_tariff_energy_rate_elec';
      const TARIFF_ENERGY_KEY_DH = 'eplus_tariff_energy_rate_dh';
      const TARIFF_ENERGY_KEY_DC = 'eplus_tariff_energy_rate_dc';
      const TARIFF_DEMAND_KEY = 'eplus_tariff_demand_rate';
      let rateElec = parseFloat(
        localStorage.getItem(TARIFF_ENERGY_KEY_ELEC) ||
          localStorage.getItem(TARIFF_ENERGY_KEY) ||
          '0.10',
      );
      let rateDH = parseFloat(localStorage.getItem(TARIFF_ENERGY_KEY_DH) || '0.06');
      let rateDC = parseFloat(localStorage.getItem(TARIFF_ENERGY_KEY_DC) || '0.08');
      let tariffDemandRate = parseFloat(localStorage.getItem(TARIFF_DEMAND_KEY) || '12'); // $/kW-month (electricity only)
      // Backwards compatibility variable
      let tariffEnergyRate = rateElec;

      function getFuelKind(meta) {
        if (!meta || meta.IsMeter != 1) return 'other';
        const name = (meta.Name || '').toLowerCase();
        if (name.includes('electric')) return 'electricity';
        if (name.includes('districtheating') || name.includes('district heating'))
          return 'districtheating';
        if (name.includes('districtcooling') || name.includes('district cooling'))
          return 'districtcooling';
        return 'other';
      }
      function computeTariffCost(seriesObj) {
        try {
          const pts = seriesObj.points;
          if (!pts.length || baseFreq !== 'Hourly') return null; // annual energy J sum to kWh
          const unit = seriesObj.meta.Units;
          const kind = getFuelKind(seriesObj.meta);
          let totalJ = 0;
          for (const p of pts) {
            const J = toJoules(p.y, unit);
            if (J == null) return null;
            totalJ += J;
          }
          const totalKWh = totalJ / 3.6e6;
          let energyRate = tariffEnergyRate;
          if (kind === 'electricity') energyRate = rateElec;
          else if (kind === 'districtheating') energyRate = rateDH;
          else if (kind === 'districtcooling') energyRate = rateDC;
          const energyCost = totalKWh * energyRate;
          // Demand: compute kW per hour (kWh for that hour) => kW
          const byMonth = new Map();
          pts.forEach((p) => {
            const date = new Date(p.x);
            const m = date.getUTCFullYear() + '-' + (date.getUTCMonth() + 1);
            const kW = (toJoules(p.y, unit) || 0) / 3.6e6;
            const cur = byMonth.get(m) || { peak: 0 };
            if (kW > cur.peak) cur.peak = kW;
            byMonth.set(m, cur);
          });
          let demandCost = 0;
          if (kind === 'electricity') {
            byMonth.forEach((v) => {
              demandCost += v.peak * tariffDemandRate;
            });
          }
          return {
            energy: energyCost,
            demand: demandCost,
            total: energyCost + demandCost,
            kind,
          };
        } catch (e) {
          return null;
        }
      }

      // Tariff popover UI
      function injectTariffUI() {
        if (document.getElementById('tariff-btn')) return;
        const container =
          document.querySelector('#toolbar-actions') || document.querySelector('#series-meta');
        if (!container) return;
        const btn = document.createElement('button');
        btn.id = 'tariff-btn';
        btn.className =
          'px-2 py-1 text-xs border rounded bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark';
        btn.textContent = '$';
        btn.title = 'Tariff settings';
        container.appendChild(btn);
        const pop = document.createElement('div');
        pop.id = 'tariff-pop';
        pop.className =
          'hidden z-50 w-64 border border-border dark:border-border-dark rounded-md bg-panel dark:bg-panel-dark shadow-lg p-3 text-xs';
        pop.style.position = 'fixed';
        pop.innerHTML = `<div class='flex justify-between items-center mb-1'><strong class='text-xs'>Tariff</strong><button id='tariff-close' class='px-1 rounded hover:bg-panel-2 dark:hover:bg-panel-2-dark' aria-label='Close'>✕</button></div>
        <div class='space-y-2'>
        <label class='block' data-tip='Electricity volumetric charge ($/kWh). Applied to total annual electric kWh.'>
          <span class='flex items-center justify-between'>
            <span>Electricity ($/kWh)</span>
            <button type='button' class='kpi-help ml-2 cursor-help select-none text-muted dark:text-muted-dark px-1 rounded hover:bg-panel-2 dark:hover:bg-panel-2-dark'>?</button>
          </span>
          <input id='tariff-energy-elec' type='number' step='0.0001' class='mt-0.5 w-full border rounded px-1 py-0.5 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark' value='${rateElec}'>
        </label>
        <label class='block' data-tip='District heating volumetric charge ($/kWh equivalent). Applied to total annual DistrictHeating kWh.'>
          <span class='flex items-center justify-between'>
            <span>District Heating ($/kWh)</span>
            <button type='button' class='kpi-help ml-2 cursor-help select-none text-muted dark:text-muted-dark px-1 rounded hover:bg-panel-2 dark:hover:bg-panel-2-dark'>?</button>
          </span>
          <input id='tariff-energy-dh' type='number' step='0.0001' class='mt-0.5 w-full border rounded px-1 py-0.5 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark' value='${rateDH}'>
        </label>
        <label class='block' data-tip='District cooling volumetric charge ($/kWh equivalent). Applied to total annual DistrictCooling kWh.'>
          <span class='flex items-center justify-between'>
            <span>District Cooling ($/kWh)</span>
            <button type='button' class='kpi-help ml-2 cursor-help select-none text-muted dark:text-muted-dark px-1 rounded hover:bg-panel-2 dark:hover:bg-panel-2-dark'>?</button>
          </span>
          <input id='tariff-energy-dc' type='number' step='0.0001' class='mt-0.5 w-full border rounded px-1 py-0.5 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark' value='${rateDC}'>
        </label>
        <label class='block' data-tip="Monthly demand charge for electricity: each month's highest hourly kW times this rate, summed over all months.">
          <span class='flex items-center justify-between'>
            <span>Demand Rate ($/kW-mo)</span>
            <button type='button' class='kpi-help ml-2 cursor-help select-none text-muted dark:text-muted-dark px-1 rounded hover:bg-panel-2 dark:hover:bg-panel-2-dark'>?</button>
          </span>
          <input id='tariff-demand' type='number' step='0.01' class='mt-0.5 w-full border rounded px-1 py-0.5 bg-panel-2 dark:bg-panel-2-dark border-border dark:border-border-dark' value='${tariffDemandRate}'>
        </label>
        </div>
  <div class='flex justify-end gap-2 mt-3'><button id='tariff-save' class='px-3 py-1.5 rounded bg-accent-strong dark:bg-accent-strong-dark text-white text-xs'>Save</button></div>`;
        // attach KPI-style tooltips for tariff help buttons
        setTimeout(() => {
          attachKpiTooltips();
        }, 0);
        document.body.appendChild(pop);
        btn.addEventListener('click', () => {
          if (pop.classList.contains('hidden')) {
            const r = btn.getBoundingClientRect();
            const margin = 6;
            const w = 260;
            let left = Math.min(window.innerWidth - w - 8, Math.max(8, r.right - w));
            let top = r.bottom + margin;
            if (top + pop.offsetHeight > window.innerHeight) {
              top = r.top - pop.offsetHeight - margin;
            }
            pop.style.left = left + 'px';
            pop.style.top = top + 'px';
            pop.classList.remove('hidden');
          } else {
            pop.classList.add('hidden');
          }
        });
        pop
          .querySelector('#tariff-close')
          .addEventListener('click', () => pop.classList.add('hidden'));
        document.addEventListener('click', (e) => {
          if (
            !pop.classList.contains('hidden') &&
            !e.target.closest('#tariff-pop') &&
            e.target !== btn
          ) {
            pop.classList.add('hidden');
          }
        });
        pop.querySelector('#tariff-save').addEventListener('click', () => {
          const erElec = parseFloat(pop.querySelector('#tariff-energy-elec').value);
          const erDH = parseFloat(pop.querySelector('#tariff-energy-dh').value);
          const erDC = parseFloat(pop.querySelector('#tariff-energy-dc').value);
          const dr = parseFloat(pop.querySelector('#tariff-demand').value);
          if (isFinite(erElec)) rateElec = erElec;
          if (isFinite(erDH)) rateDH = erDH;
          if (isFinite(erDC)) rateDC = erDC;
          if (isFinite(dr)) tariffDemandRate = dr;
          // keep backwards compatibility single key for electricity
          tariffEnergyRate = rateElec;
          localStorage.setItem(TARIFF_ENERGY_KEY_ELEC, rateElec);
          localStorage.setItem(TARIFF_ENERGY_KEY_DH, rateDH);
          localStorage.setItem(TARIFF_ENERGY_KEY_DC, rateDC);
          localStorage.setItem(TARIFF_ENERGY_KEY, rateElec);
          localStorage.setItem(TARIFF_DEMAND_KEY, tariffDemandRate);
          pop.classList.add('hidden');
          renderAll();
        });
      }
      injectTariffUI();

      async function renderChart(series, opts = {}) {
        await ensureD3();
        const container = $('chart');
        container.innerHTML = '';
        const rect = container.getBoundingClientRect();
        const width = rect.width,
          height = rect.height;
        const metas = [...selected.values()].map((v) => v.meta);
        let consistentUnits = metas.length && metas.every((m) => m.Units === metas[0].Units);
        let primaryMeta = consistentUnits ? metas[0] : null;
        if (!primaryMeta && metas.length) {
          // Fallback: choose first if all share same unit kind (energy/power/temperature)
          const k0 = unitKind(metas[0].Units);
          if (
            ['energy', 'power', 'temperature'].includes(k0) &&
            metas.every((m) => unitKind(m.Units) === k0)
          ) {
            primaryMeta = metas[0];
          }
        }
        const normalize = opts.normalize === true;
        const showSecondary =
          !normalize &&
          primaryMeta &&
          ['energy', 'power', 'temperature'].includes(unitKind(primaryMeta.Units));
        const m = {
          top: 16,
          right: showSecondary ? 68 : 24,
          bottom: baseFreq === 'Hourly' ? 56 : 36,
          left: 56,
        };
        const w = width - m.left - m.right,
          h = height - m.top - m.bottom;
        const {
          axis: axisColor,
          grid: gridColor,
          tooltipBg,
          text: textColor,
          border: borderColor,
          accent,
          accentStrong,
        } = chartColors();
        const svg = d3.select(container).append('svg').attr('width', width).attr('height', height);
        const g = svg.append('g').attr('transform', `translate(${m.left},${m.top})`);
        const peaks = new Map();
        if (normalize) {
          series.forEach((s) => {
            const vals = s.points
              .map((p) => convertUnits(p.y, s.meta.Units))
              .filter((v) => isFinite(v));
            const pk = Math.max(...vals, 0);
            peaks.set(s.id, pk > 0 ? pk : 1);
          });
        }
        function normVal(val, s) {
          if (!normalize) return val;
          const pk = peaks.get(s.id) || 1;
          return (val / pk) * 100;
        }
        const allY = series.flatMap((s) =>
          s.points.map((p) => normVal(convertUnits(p.y, s.meta.Units), s)),
        );
        const y = d3
          .scaleLinear()
          .domain([Math.min(0, d3.min(allY)), d3.max(allY)])
          .nice()
          .range([h, 0]);
        g.append('g')
          .attr('class', 'grid')
          .call(d3.axisLeft(y).ticks(6).tickSize(-w).tickFormat(''))
          .selectAll('line')
          .attr('stroke', gridColor)
          .attr('stroke-opacity', 0.35);
        g.select('.grid').select('.domain').remove();
        if (baseFreq === 'Hourly') {
          const fullDomain = d3.extent(series.flatMap((s) => s.points.map((p) => p.x)));
          const x = d3.scaleUtc().domain(fullDomain).range([0, w]);
          if (
            currentXDomain &&
            currentXDomain[0] >= fullDomain[0] &&
            currentXDomain[1] <= fullDomain[1]
          )
            x.domain(currentXDomain);
          else currentXDomain = null;
          // More frequent month ticks with responsive skipping
          const allMonths = d3.timeMonth.range(
            d3.timeMonth.floor(fullDomain[0]),
            d3.timeMonth.offset(fullDomain[1], 1),
          );
          let monthStep = 1;
          if (w < 420) monthStep = 2; // skip every other month on small width
          if (w < 320) monthStep = 3; // skip more on very narrow
          const monthTicks = allMonths.filter((_, i) => i % monthStep === 0);
          const gx = g.append('g').attr('transform', `translate(0,${h})`);
          function applyMonthAxis() {
            const spanMs = x.domain()[1] - x.domain()[0];
            const days = spanMs / 86400000;
            // If zoomed in to < 40 days, switch to default ticks for readability
            if (days < 40) {
              gx.call(d3.axisBottom(x).ticks(w < 480 ? (w < 360 ? 4 : 6) : 8));
              return;
            }
            const allMonths = d3.timeMonth.range(
              d3.timeMonth.floor(x.domain()[0]),
              d3.timeMonth.offset(x.domain()[1], 1),
            );
            let monthStep = 1;
            if (w < 420) monthStep = 2;
            if (w < 320) monthStep = 3;
            const monthTicks = allMonths.filter((_, i) => i % monthStep === 0);
            gx.call(
              d3
                .axisBottom(x)
                .tickValues(monthTicks)
                .tickFormat((d) => d3.timeFormat('%b')(d)),
            );
          }
          applyMonthAxis();
          const gy = g.append('g').call(d3.axisLeft(y).ticks(6));
          if (showSecondary) {
            const oppLabel = convertUnitLabelOpposite(primaryMeta.Units);
            const axisR = d3
              .axisRight(y)
              .ticks(6)
              .tickFormat((t) => fmt(convertDisplayedToOpposite(t, primaryMeta.Units)));
            const gyR = g.append('g').attr('transform', `translate(${w},0)`).call(axisR);
            gyR.selectAll('path,line').attr('stroke', axisColor);
            gyR.selectAll('text').attr('fill', axisColor);
            if (oppLabel) {
              g.append('text')
                .attr('x', w)
                .attr('y', -4)
                .attr('text-anchor', 'end')
                .attr('fill', axisColor)
                .attr('font-size', '10px')
                .text(oppLabel);
            }
          }
          gx.selectAll('path,line').attr('stroke', axisColor);
          gy.selectAll('path,line').attr('stroke', axisColor);
          gx.selectAll('text').attr('fill', axisColor);
          gy.selectAll('text').attr('fill', axisColor);
          for (const s of series) {
            const line = d3
              .line()
              .x((d) => x(d.x))
              .y((d) => y(normVal(convertUnits(d.y, s.meta.Units), s)));
            g.append('path')
              .datum(s.points)
              .attr('fill', 'none')
              .attr('stroke-width', 1.8)
              .attr('stroke', s.color)
              .attr('class', 'series')
              .attr('d', line);
          }
          if (zoomEnabled) {
            const brush = d3
              .brushX()
              .extent([
                [0, 0],
                [w, h],
              ])
              .on('end', (ev) => {
                const sel = ev.selection;
                if (!sel) {
                  x.domain(fullDomain);
                  currentXDomain = null;
                } else {
                  x.domain(sel.map(x.invert));
                  currentXDomain = x.domain().slice();
                }
                redraw();
              });
            const bG = g.append('g').attr('class', 'brush').call(brush);
            bG.selectAll('.selection')
              .attr('fill', accent)
              .attr('fill-opacity', 0.15)
              .attr('stroke', accentStrong);
            $('zoom-hint').classList.remove('hidden');
          } else {
            $('zoom-hint').classList.add('hidden');
          }
          function redraw() {
            applyMonthAxis();
            gx.selectAll('path,line').attr('stroke', axisColor);
            gx.selectAll('text').attr('fill', axisColor);
            g.selectAll('path.series').remove();
            for (const s of series) {
              g.append('path')
                .datum(s.points)
                .attr('class', 'series')
                .attr('fill', 'none')
                .attr('stroke-width', 1.8)
                .attr('stroke', s.color)
                .attr(
                  'd',
                  d3
                    .line()
                    .x((p) => x(p.x))
                    .y((p) => y(normVal(convertUnits(p.y, s.meta.Units), s))),
                );
            }
          }
          redraw();
          svg.on('dblclick', () => {
            x.domain(fullDomain);
            currentXDomain = null;
            redraw();
          });
          const tooltip = d3
            .select(container)
            .append('div')
            .style('position', 'absolute')
            .style('pointer-events', 'none')
            .style('background', tooltipBg)
            .style('border', '1px solid ' + borderColor)
            .style('color', textColor)
            .style('padding', '6px 8px')
            .style('border-radius', '6px')
            .style('font-size', '12px')
            .style('display', 'none');
          const allPts = series
            .flatMap((s) =>
              s.points.map((p) => ({
                x: p.x,
                y: normVal(convertUnits(p.y, s.meta.Units), s),
                raw: convertUnits(p.y, s.meta.Units),
                label: p.label,
                color: s.color,
                name: s.meta.Name,
                units: normalize ? '%' : convertUnitLabel(s.meta.Units),
              })),
            )
            .sort((a, b) => a.x - b.x);
          const bisect = d3.bisector((d) => d.x).left;
          svg
            .on('mousemove', (ev) => {
              const [mx] = d3.pointer(ev, g.node());
              const x0 = x.invert(mx);
              const i = Math.min(allPts.length - 1, Math.max(0, bisect(allPts, x0)));
              const d = allPts[i];
              tooltip
                .style('display', 'block')
                .style('left', ev.offsetX + 12 + 'px')
                .style('top', ev.offsetY - 24 + 'px')
                .html(
                  `<div><strong>${d.label}</strong></div><div><span style='color:${d.color}'>${
                    d.name
                  }</span> — ${fmt(d.y)} ${d.units || ''}${
                    normalize
                      ? ` <span class='text-muted dark:text-muted-dark'>(raw ${fmt(d.raw)})</span>`
                      : ''
                  }</div>`,
                );
            })
            .on('mouseleave', () => tooltip.style('display', 'none'));
        } else {
          const x = d3
            .scaleBand()
            .domain(series[0]?.points.map((p) => p.xLabel) || [])
            .range([0, w])
            .padding(0.2);
          const x1 = d3
            .scaleBand()
            .domain(series.map((s) => String(s.id)))
            .range([0, x.bandwidth()])
            .padding(0.05);
          // Monthly bars: show all months but skip on very small widths to avoid overlap
          const rawMonthLabels = series[0]?.points.map((p) => p.xLabel) || [];
          const monthLabelFmt = (raw) => {
            if (!raw) return raw;
            const m = raw.match(/-M(\d{2})/i);
            if (m) {
              const idx = parseInt(m[1], 10);
              if (idx >= 1 && idx <= 12) return d3.timeFormat('%b')(new Date(2000, idx - 1, 1));
            }
            // Fallback: if raw already looks like a month name, abbreviate
            const lower = raw.toLowerCase();
            const monthNames = [
              'jan',
              'feb',
              'mar',
              'apr',
              'may',
              'jun',
              'jul',
              'aug',
              'sep',
              'oct',
              'nov',
              'dec',
            ];
            const found = monthNames.find((mn) => lower.startsWith(mn));
            if (found) return found.charAt(0).toUpperCase() + found.slice(1, 3); // Jan, Feb...
            return raw;
          };
          const monthLabels = rawMonthLabels;
          let step = 1;
          if (w < 420) step = 2;
          if (w < 320) step = 3;
          const shown = monthLabels.filter((_, i) => i % step === 0);
          const gx = g
            .append('g')
            .attr('transform', `translate(0,${h})`)
            .call(d3.axisBottom(x).tickValues(shown).tickFormat(monthLabelFmt));
          const gy = g.append('g').call(d3.axisLeft(y).ticks(6));
          if (showSecondary) {
            const axisR = d3
              .axisRight(y)
              .ticks(6)
              .tickFormat((t) => fmt(convertDisplayedToOpposite(t, primaryMeta.Units)));
            const gyR = g.append('g').attr('transform', `translate(${w},0)`).call(axisR);
            gyR.selectAll('path,line').attr('stroke', axisColor);
            gyR.selectAll('text').attr('fill', axisColor);
            if (convertUnitLabelOpposite(primaryMeta.Units)) {
              g.append('text')
                .attr('x', w)
                .attr('y', -4)
                .attr('text-anchor', 'end')
                .attr('fill', axisColor)
                .attr('font-size', '10px')
                .text(convertUnitLabelOpposite(primaryMeta.Units));
            }
          }
          gx.selectAll('path,line').attr('stroke', axisColor);
          gy.selectAll('path,line').attr('stroke', axisColor);
          gx.selectAll('text')
            .attr('fill', axisColor)
            .style('text-anchor', 'end')
            .attr('transform', 'rotate(-30)');
          gy.selectAll('text').attr('fill', axisColor);
          series.forEach((s) => {
            g.selectAll(`rect.bar-${s.id}`)
              .data(s.points)
              .enter()
              .append('rect')
              .attr('x', (d) => x(d.xLabel) + x1(String(s.id)))
              .attr('y', (d) => y(convertUnits(d.y, s.meta.Units)))
              .attr('width', x1.bandwidth())
              .attr('height', (d) => h - y(convertUnits(d.y, s.meta.Units)))
              .attr('fill', s.color);
          });
          if (zoomEnabled) {
            // Implement simple band zoom: click-drag creates selection over bands
            const drag = d3
              .brushX()
              .extent([
                [0, 0],
                [w, h],
              ])
              .on('end', (ev) => {
                const sel = ev.selection;
                if (!sel) return;
                const [x0, x1px] = sel;
                const chosen = monthLabels.filter((ml) => {
                  const cx = (x(ml) || 0) + x.bandwidth() / 2;
                  return cx >= x0 && cx <= x1px;
                });
                if (chosen.length && chosen.length < monthLabels.length) {
                  const newDomain = monthLabels.slice(
                    monthLabels.indexOf(chosen[0]),
                    monthLabels.indexOf(chosen[chosen.length - 1]) + 1,
                  );
                  x.domain(newDomain);
                  gx.call(d3.axisBottom(x).tickValues(shown).tickFormat(monthLabelFmt));
                  gx.selectAll('path,line').attr('stroke', axisColor);
                  gx.selectAll('text')
                    .attr('fill', axisColor)
                    .style('text-anchor', 'end')
                    .attr('transform', 'rotate(-30)');
                  g.selectAll('rect').remove();
                  series.forEach((s) => {
                    g.selectAll(`rect.bar-${s.id}`)
                      .data(s.points.filter((p) => x.domain().includes(p.xLabel)))
                      .enter()
                      .append('rect')
                      .attr('x', (d) => x(d.xLabel) + x1(String(s.id)))
                      .attr('y', (d) => y(convertUnits(d.y, s.meta.Units)))
                      .attr('width', x1.bandwidth())
                      .attr('height', (d) => h - y(convertUnits(d.y, s.meta.Units)))
                      .attr('fill', s.color);
                  });
                }
                g.select('.band-zoom').call(drag.move, null);
              });
            const bz = g.append('g').attr('class', 'band-zoom').call(drag);
            bz.selectAll('.selection')
              .attr('fill', accent)
              .attr('fill-opacity', 0.15)
              .attr('stroke', accentStrong);
          }
        }
        const leg = $('legend');
        leg.innerHTML = '';
        series.forEach((s) => {
          const item = document.createElement('button');
          item.className =
            'text-xs px-2 py-1 rounded border border-border dark:border-border-dark transition-colors';
          if (s.visible !== false) item.classList.add('bg-panel-2', 'dark:bg-panel-2-dark');
          item.innerHTML = `<span style="display:inline-block;width:10px;height:10px;background:${s.color};border-radius:2px;margin-right:6px;vertical-align:middle"></span>${s.meta.Name}`;
          item.onclick = () => {
            const v = selected.get(s.id);
            v.visible = !v.visible;
            selected.set(s.id, v);
            renderAll();
          };
          leg.appendChild(item);
        });
      }

      function renderScatter(series) {
        // Expect at least 2 visible series; use first two as X/Y or user-chosen pair
        const container = $('chart');
        container.innerHTML = '';
        if (series.length < 2) {
          container.innerHTML =
            '<div class="text-xs text-muted dark:text-muted-dark p-3">Select at least two series for Scatter plot.</div>';
          $('legend').innerHTML = '';
          $('insights').textContent = '';
          return;
        }
        const ordered = series.filter((s) => s.visible !== false);
        if (ordered.length < 2) {
          container.innerHTML =
            '<div class="text-xs text-muted dark:text-muted-dark p-3">At least two visible series required (toggle legends).</div>';
          return;
        }
        // Use scatterPair if valid; else first two
        let sx, sy;
        if (
          scatterPair &&
          ordered.some((s) => s.id === scatterPair.x) &&
          ordered.some((s) => s.id === scatterPair.y)
        ) {
          sx = ordered.find((s) => s.id === scatterPair.x);
          sy = ordered.find((s) => s.id === scatterPair.y);
        } else {
          sx = ordered[0];
          sy = ordered[1];
          scatterPair = { x: sx.id, y: sy.id };
        }
        // Only compare overlapping timestamps/labels; require same length/time indexes
        const isHourly = baseFreq === 'Hourly';
        let points = [];
        if (isHourly) {
          // build map from time index (x) -> value for sx, then join for sy
          const mapX = new Map();
          sx.points.forEach((p) => mapX.set(p.x, convertUnits(p.y, sx.meta.Units)));
          sy.points.forEach((p) => {
            const vx = mapX.get(p.x);
            if (vx != null)
              points.push({ xVal: vx, yVal: convertUnits(p.y, sy.meta.Units), t: p.x });
          });
        } else {
          // monthly label join
          const mapX = new Map();
          sx.points.forEach((p) => mapX.set(p.xLabel, convertUnits(p.y, sx.meta.Units)));
          sy.points.forEach((p) => {
            const vx = mapX.get(p.xLabel);
            if (vx != null)
              points.push({ xVal: vx, yVal: convertUnits(p.y, sy.meta.Units), lbl: p.xLabel });
          });
        }
        if (!points.length) {
          container.innerHTML =
            '<div class="text-xs text-muted dark:text-muted-dark p-3">No overlapping points between selected series.</div>';
          return;
        }
        // Stats & regression (ordinary least squares)
        const n = points.length;
        const sumX = points.reduce((a, p) => a + p.xVal, 0);
        const sumY = points.reduce((a, p) => a + p.yVal, 0);
        const sumXY = points.reduce((a, p) => a + p.xVal * p.yVal, 0);
        const sumX2 = points.reduce((a, p) => a + p.xVal * p.xVal, 0);
        const meanX = sumX / n,
          meanY = sumY / n;
        const denom = n * sumX2 - sumX * sumX;
        let slope = null,
          intercept = null,
          r2 = null;
        if (denom !== 0) {
          slope = (n * sumXY - sumX * sumY) / denom;
          intercept = meanY - slope * meanX;
          // r^2
          const ssTot = points.reduce((a, p) => a + Math.pow(p.yVal - meanY, 2), 0);
          const ssRes = points.reduce(
            (a, p) => a + Math.pow(p.yVal - (slope * p.xVal + intercept), 2),
            0,
          );
          r2 = ssTot ? 1 - ssRes / ssTot : 0;
        }
        const {
          axis: axisColor,
          grid: gridColor,
          text: textColor,
          tooltipBg,
          border: borderColor,
        } = chartColors();
        // Layout
        const rect = container.getBoundingClientRect();
        const width = rect.width,
          height = rect.height;
        const m = { top: 16, right: 32, bottom: 52, left: 60 };
        const w = width - m.left - m.right,
          h = height - m.top - m.bottom;
        const xScale = d3
          .scaleLinear()
          .domain(d3.extent(points, (d) => d.xVal))
          .nice()
          .range([0, w]);
        const yScale = d3
          .scaleLinear()
          .domain(d3.extent(points, (d) => d.yVal))
          .nice()
          .range([h, 0]);
        const svg = d3.select(container).append('svg').attr('width', width).attr('height', height);
        const g = svg.append('g').attr('transform', `translate(${m.left},${m.top})`);
        // grid
        g.append('g')
          .attr('class', 'grid')
          .call(d3.axisLeft(yScale).ticks(6).tickSize(-w).tickFormat(''))
          .selectAll('line')
          .attr('stroke', gridColor)
          .attr('stroke-opacity', 0.35);
        g.select('.grid').select('.domain').remove();
        const gx = g
          .append('g')
          .attr('transform', `translate(0,${h})`)
          .call(d3.axisBottom(xScale).ticks(6));
        const gy = g.append('g').call(d3.axisLeft(yScale).ticks(6));
        gx.selectAll('path,line').attr('stroke', axisColor);
        gy.selectAll('path,line').attr('stroke', axisColor);
        gx.selectAll('text').attr('fill', axisColor);
        gy.selectAll('text').attr('fill', axisColor);
        let regLineEl = null;
        function drawRegression() {
          if (regLineEl) regLineEl.remove();
          if (!scatterShowRegression || slope == null) return;
          const linePts = xScale.domain().map((x) => ({ x, y: slope * x + intercept }));
          regLineEl = g
            .append('path')
            .datum(linePts)
            .attr('fill', 'none')
            .attr('stroke', palette[0])
            .attr('stroke-width', 1.2)
            .attr('stroke-dasharray', '4,4')
            .attr('opacity', 0.9)
            .attr(
              'd',
              d3
                .line()
                .x((d) => xScale(d.x))
                .y((d) => yScale(d.y)),
            );
        }
        drawRegression();
        const tooltip = d3
          .select(container)
          .append('div')
          .style('position', 'absolute')
          .style('pointer-events', 'none')
          .style('background', tooltipBg)
          .style('border', '1px solid ' + borderColor)
          .style('color', textColor)
          .style('padding', '6px 8px')
          .style('border-radius', '6px')
          .style('font-size', '12px')
          .style('display', 'none');
        g.selectAll('circle.pt')
          .data(points)
          .enter()
          .append('circle')
          .attr('class', 'pt')
          .attr('cx', (p) => xScale(p.xVal))
          .attr('cy', (p) => yScale(p.yVal))
          .attr('r', 3)
          .attr('fill', palette[1])
          .attr('opacity', 0.85)
          .on('mousemove', (ev, p) => {
            tooltip
              .style('display', 'block')
              .style('left', ev.offsetX + 12 + 'px')
              .style('top', ev.offsetY - 24 + 'px')
              .html(`<div><strong>${fmt(p.xVal)}, ${fmt(p.yVal)}</strong></div>`);
          })
          .on('mouseleave', () => tooltip.style('display', 'none'));
        // axis labels
        g.append('text')
          .attr('x', w / 2)
          .attr('y', h + 40)
          .attr('text-anchor', 'middle')
          .attr('fill', axisColor)
          .attr('font-size', '12px')
          .text(`${sx.meta.Name} (${convertUnitLabel(sx.meta.Units)})`);
        g.append('text')
          .attr('transform', 'rotate(-90)')
          .attr('x', -h / 2)
          .attr('y', -44)
          .attr('text-anchor', 'middle')
          .attr('fill', axisColor)
          .attr('font-size', '12px')
          .text(`${sy.meta.Name} (${convertUnitLabel(sy.meta.Units)})`);
        // summary / insights
        const statsHtml =
          slope != null
            ? `Slope: ${fmt(slope)} | Intercept: ${fmt(intercept)} | R²: ${r2.toFixed(3)}${
                scatterShowRegression ? '' : ' (hidden)'
              }`
            : 'Insufficient variance for regression';
        $('insights').innerHTML = `Scatter (${points.length} pts) — ${statsHtml}`;
        // legend includes clickable X/Y swap and choose pair
        const leg = $('legend');
        leg.innerHTML = '';
        function button(label, handler, active = true) {
          const b = document.createElement('button');
          b.className = 'text-xs px-2 py-1 rounded border border-border dark:border-border-dark';
          if (active) b.classList.add('bg-panel-2', 'dark:bg-panel-2-dark');
          b.textContent = label;
          b.onclick = handler;
          leg.appendChild(b);
          return b;
        }
        button(`X: ${sx.meta.Name}`, () => {
          scatterPair = { x: sy.id, y: sx.id };
          renderAll();
        });
        button(`Y: ${sy.meta.Name}`, () => {
          scatterPair = { x: sy.id, y: sx.id };
          renderAll();
        });
        // offer cycle through other series if more than 2
        if (ordered.length > 2) {
          button('Next Pair', () => {
            const idxX = ordered.findIndex((s) => s.id === scatterPair.x);
            const idxY = ordered.findIndex((s) => s.id === scatterPair.y);
            const next = (i) => ordered[(i + 1) % ordered.length];
            const newX = next(idxX);
            let newY = next(idxY + 1);
            if (newY.id === newX.id) newY = next(ordered.findIndex((s) => s.id === newX.id) + 1);
            scatterPair = { x: newX.id, y: newY.id };
            renderAll();
          });
        }
        // regression toggle
        const regBtn = button(
          'Regression',
          () => {
            scatterShowRegression = !scatterShowRegression;
            regBtn.classList.toggle('bg-panel-2');
            regBtn.classList.toggle('dark:bg-panel-2-dark');
            drawRegression();
            $('insights').innerHTML = `Scatter (${points.length} pts) — ${
              slope != null
                ? `Slope: ${fmt(slope)} | Intercept: ${fmt(intercept)} | R²: ${r2.toFixed(3)}${
                    scatterShowRegression ? '' : ' (hidden)'
                  }`
                : 'Insufficient variance for regression'
            }`;
          },
          scatterShowRegression,
        );
      }

      function toLDC(points, units, normalize) {
        const vals = points.map((p) => convertUnits(p.y, units)).filter((v) => Number.isFinite(v));
        if (!vals.length) return [];
        vals.sort((a, b) => b - a);
        const peak = vals[0];
        const n = vals.length;
        return vals.map((v, i) => ({
          x: n > 1 ? (i / (n - 1)) * 100 : 0,
          y: normalize ? (v / peak) * 100 : v,
        }));
      }

      async function renderLDC(series) {
        await ensureD3();
        const container = $('chart');
        container.innerHTML = '';
        const rect = container.getBoundingClientRect();
        const width = rect.width,
          height = rect.height;
        const m = { top: 16, right: 24, bottom: 40, left: 56 },
          w = width - m.left - m.right,
          h = height - m.top - m.bottom;
        const {
          axis: axisColor,
          grid: gridColor,
          text: textColor,
          border: borderColor,
          tooltipBg,
          accent,
          accentStrong,
        } = chartColors();
        const normalize = $('ldc-normalize')?.checked === true;

        const curves = series
          .map((s) => ({
            ...s,
            points: toLDC(s.points, s.meta.Units, normalize),
          }))
          .filter((c) => c.points.length);
        if (!curves.length) {
          $('insights').textContent = 'No data available for LDC.';
          return;
        }

        const allY = curves.flatMap((c) => c.points.map((p) => p.y));
        const rawMin = d3.min(allY);
        const rawMax = d3.max(allY);
        // Ensure domain includes 0 if values cross it, or if all values are on one side keep that side + 0 for reference when all negative
        let domMin = rawMin;
        let domMax = rawMax;
        if (rawMin < 0 && rawMax > 0) {
          domMin = rawMin;
          domMax = rawMax;
        } else if (rawMax <= 0) {
          // all negative
          domMin = rawMin;
          domMax = 0; // include zero baseline for context
        } else if (rawMin >= 0) {
          domMin = 0; // start at zero for all positive
          domMax = rawMax;
        }
        const x = d3.scaleLinear().domain([0, 100]).range([0, w]);
        const y = d3.scaleLinear().domain([domMin, domMax]).nice().range([h, 0]);

        const svg = d3.select(container).append('svg').attr('width', width).attr('height', height);
        const g = svg.append('g').attr('transform', `translate(${m.left},${m.top})`);

        g.append('g')
          .attr('class', 'grid')
          .call(d3.axisLeft(y).ticks(6).tickSize(-w).tickFormat(''))
          .selectAll('line')
          .attr('stroke', gridColor)
          .attr('stroke-opacity', 0.35);
        g.select('.grid').select('.domain').remove();

        const gx = g
          .append('g')
          .attr('transform', `translate(0,${h})`)
          .call(
            d3
              .axisBottom(x)
              .ticks(6)
              .tickFormat((d) => d + '%'),
          );
        const gy = g.append('g').call(d3.axisLeft(y).ticks(6));
        gx.selectAll('path,line').attr('stroke', axisColor);
        gy.selectAll('path,line').attr('stroke', axisColor);
        gx.selectAll('text').attr('fill', axisColor);
        gy.selectAll('text').attr('fill', axisColor);

        const line = d3
          .line()
          .x((d) => x(d.x))
          .y((d) => y(d.y));
        curves.forEach((c) => {
          g.append('path')
            .datum(c.points)
            .attr('fill', 'none')
            .attr('stroke', c.color)
            .attr('stroke-width', 1.8)
            .attr('d', line);
        });

        // Zero baseline if needed (negative values present)
        if (domMin < 0) {
          g.append('line')
            .attr('x1', 0)
            .attr('x2', w)
            .attr('y1', y(0))
            .attr('y2', y(0))
            .attr('stroke', axisColor)
            .attr('stroke-width', 1)
            .attr('opacity', 0.6);
        }

        [10, 50, 90].forEach((p) => {
          const xx = x(p);
          g.append('line')
            .attr('x1', xx)
            .attr('x2', xx)
            .attr('y1', 0)
            .attr('y2', h)
            .attr('stroke', axisColor)
            .attr('stroke-dasharray', '2,3')
            .attr('opacity', 0.6);
        });

        // textColor, borderColor, tooltipBg already from chartColors()
        const tooltip = d3
          .select(container)
          .append('div')
          .style('position', 'absolute')
          .style('pointer-events', 'none')
          .style('background', tooltipBg)
          .style('border', '1px solid ' + borderColor)
          .style('color', textColor)
          .style('padding', '6px 8px')
          .style('border-radius', '6px')
          .style('font-size', '12px')
          .style('display', 'none');

        svg
          .on('mousemove', (event) => {
            const [mx] = d3.pointer(event, g.node());
            const px = Math.max(0, Math.min(100, x.invert(mx)));
            const rows = curves
              .map((c) => {
                const a = c.points;
                if (!a.length) return null;
                let i = Math.floor((px / 100) * (a.length - 1));
                i = Math.max(0, Math.min(a.length - 1, i));
                return { name: c.meta.Name, color: c.color, y: a[i].y };
              })
              .filter(Boolean)
              .sort((a, b) => b.y - a.y);
            const unitLabel = normalize ? '%' : convertUnitLabel(curves[0].meta.Units);
            tooltip
              .style('display', 'block')
              .style('left', event.offsetX + 12 + 'px')
              .style('top', event.offsetY - 24 + 'px')
              .html(
                `<div><strong>P${px.toFixed(0)}</strong></div>` +
                  rows
                    .map(
                      (r) =>
                        `<div><span style=\"color:${r.color}\">${escapeHtml(r.name)}</span> — ${fmt(
                          r.y,
                        )} ${unitLabel || ''}</div>`,
                    )
                    .join(''),
              );
          })
          .on('mouseleave', () => tooltip.style('display', 'none'));

        const leg = $('legend');
        leg.innerHTML = '';
        curves.forEach((s) => {
          const item = document.createElement('button');
          item.className =
            'text-xs px-2 py-1 rounded border border-border dark:border-border-dark transition-colors';
          if (s.visible !== false) item.classList.add('bg-panel-2', 'dark:bg-panel-2-dark');
          item.innerHTML = `<span style=\"display:inline-block;width:10px;height:10px;background:${s.color};border-radius:2px;margin-right:6px;vertical-align:middle\"></span>${s.meta.Name}`;
          item.onclick = () => {
            const v = selected.get(s.id);
            v.visible = !v.visible;
            selected.set(s.id, v);
            renderAll();
          };
          leg.appendChild(item);
        });

        const el = $('insights');
        const lbl = normalize ? '(normalized to each series peak)' : '';
        el.innerHTML = `Load duration curve ${lbl}`;
        $('units').textContent = normalize ? '%' : convertUnitLabel(curves[0]?.meta?.Units || '');
      }

      async function renderLoadBalance(series) {
        await ensureD3();
        const container = $('chart');
        const hadLoading = !!document.getElementById('lb-loading');
        // Required variable groups (any one of the alternatives in names[] will satisfy)
        const IDF_LOAD_BALANCE_SNIPPET = `! Load Balance Required Outputs (Monthly variant)\nOutput:Variable,*,Zone Air System Sensible Heating Energy,Monthly;\nOutput:Variable,*,Zone Air System Sensible Cooling Energy,Monthly;\n! or (Ideal Loads)\n! Output:Variable,*,Zone Ideal Loads Supply Air Sensible Heating Energy,Monthly;\n! Output:Variable,*,Zone Ideal Loads Supply Air Sensible Cooling Energy,Monthly;\n\n! Internal Gains\nOutput:Variable,*,People Sensible Heat Gain Energy,Monthly;\nOutput:Variable,*,Lights Total Heating Energy,Monthly;\nOutput:Variable,*,Electric Equipment Total Heating Energy,Monthly;\nOutput:Variable,*,Hot Water Equipment Total Heating Energy,Monthly;\n\n! Solar\nOutput:Variable,*,Zone Windows Total Transmitted Solar Radiation Energy,Monthly;\n\n! Infiltration / ventilation\nOutput:Variable,*,Zone Infiltration Sensible Heat Gain Energy,Monthly;\nOutput:Variable,*,Zone Infiltration Sensible Heat Loss Energy,Monthly;\nOutput:Variable,*,Zone Ventilation Sensible Heat Gain Energy,Monthly;\nOutput:Variable,*,Zone Ventilation Sensible Heat Loss Energy,Monthly;\n\n! Conduction & storage\nOutput:Variable,*,Surface Inside Face Conduction Heat Gain Energy,Monthly;\nOutput:Variable,*,Surface Inside Face Conduction Heat Loss Energy,Monthly;\nOutput:Variable,*,Surface Inside Face Conduction Heat Storage Energy,Monthly;\nOutput:Variable,*,Zone Air Heat Balance Air Energy Storage Energy,Monthly;`;
        const CATS = [
          {
            id: 'heating',
            label: 'Heating',
            names: [
              'Zone Air System Sensible Heating Energy',
              'Zone Ideal Loads Supply Air Sensible Heating Energy',
            ],
            sign: +1,
          },
          {
            id: 'cooling',
            label: 'Cooling Needed',
            names: [
              'Zone Air System Sensible Cooling Energy',
              'Zone Ideal Loads Supply Air Sensible Cooling Energy',
            ],
            sign: -1,
          },
          {
            id: 'internal',
            label: 'Internal Gains',
            names: [
              'People Sensible Heat Gain Energy',
              'Lights Total Heating Energy',
              'Electric Equipment Total Heating Energy',
              'Hot Water Equipment Total Heating Energy',
            ],
            sign: +1,
          },
          {
            id: 'solar',
            label: 'Window Solar',
            names: ['Zone Windows Total Transmitted Solar Radiation Energy'],
            sign: +1,
          },
          {
            id: 'inf_gain',
            label: 'Infiltration Gain',
            names: ['Zone Infiltration Sensible Heat Gain Energy'],
            sign: +1,
          },
          {
            id: 'inf_loss',
            label: 'Infiltration Loss',
            names: ['Zone Infiltration Sensible Heat Loss Energy'],
            sign: -1,
          },
          {
            id: 'vent_gain',
            label: 'Ventilation Gain',
            names: ['Zone Ventilation Sensible Heat Gain Energy'],
            sign: +1,
          },
          {
            id: 'vent_loss',
            label: 'Ventilation Loss',
            names: ['Zone Ventilation Sensible Heat Loss Energy'],
            sign: -1,
          },
          {
            id: 'cond_gain',
            label: 'Window Conduction',
            names: ['Surface Inside Face Conduction Heat Gain Energy'],
            sign: +1,
          },
          {
            id: 'cond_loss',
            label: 'Wall Conduction',
            names: ['Surface Inside Face Conduction Heat Loss Energy'],
            sign: -1,
          },
          {
            id: 'storage',
            label: 'Air / Surface Storage',
            names: [
              'Surface Inside Face Conduction Heat Storage Energy',
              'Zone Air Heat Balance Air Energy Storage Energy',
            ],
            sign: 0,
          },
        ];
        if (!db || !dict) {
          container.innerHTML = `<div class='text-xs text-muted dark:text-muted-dark p-3'>Load a database first.</div>`;
          return;
        }
        // Build index of dictionary names -> entries (Hourly or Monthly). Prefer Hourly if present.
        const byName = dict
          .filter((d) => d.freq === 'Hourly' || d.freq === 'Monthly')
          .reduce((m, d) => {
            (m[d.Name] ||= []).push(d);
            return m;
          }, {});
        const missing = [];
        // Helper to collect rows per category
        function pad2(n) {
          return String(n).padStart(2, '0');
        }
        // Map env-month -> category totals (in Joules, signed)
        let monthLabelsLocal, catTotals;
        if (__loadBalanceCache) {
          ({ monthLabels: monthLabelsLocal, catTotals, missing } = __loadBalanceCache);
        } else {
          const monthKeys = new Set();
          const catTotalsLocal = new Map();
          CATS.forEach((c) => catTotalsLocal.set(c.id, new Map()));
          // Pre-build filtered lists for each variable name (Hourly preferred) to avoid repeated some/filter operations inside loops
          const nameToEntries = {};
          for (const nm in byName) {
            const arr = byName[nm];
            if (!arr) continue;
            nameToEntries[nm] = arr.some((e) => e.freq === 'Hourly')
              ? arr.filter((e) => e.freq === 'Hourly')
              : arr;
          }
          for (const cat of CATS) {
            let anyFound = false;
            for (const nm of cat.names) {
              const entries = nameToEntries[nm];
              if (!entries) continue;
              anyFound = true;
              for (let ei = 0; ei < entries.length; ei++) {
                const entry = entries[ei];
                const rows = queryTimeSeries(entry.id);
                const mMap = catTotalsLocal.get(cat.id);
                const sign = cat.sign;
                const units = entry.Units;
                for (let ri = 0; ri < rows.length; ri++) {
                  const r = rows[ri];
                  const label = `E${r.env}-M${pad2(r.month || 1)}`;
                  monthKeys.add(label);
                  let valJ = toJoules(Number(r.value), units) ?? Number(r.value);
                  if (!isFinite(valJ)) continue;
                  const applied = sign === 0 ? valJ : valJ * sign;
                  mMap.set(label, (mMap.get(label) || 0) + applied);
                }
              }
            }
            if (!anyFound) missing.push(cat.label);
          }
          monthLabelsLocal = [...monthKeys].sort();
          catTotals = catTotalsLocal;
          __loadBalanceCache = { monthLabels: monthLabelsLocal, catTotals, missing: [...missing] };
        }
        const monthLabels = monthLabelsLocal;
        if (monthLabels.length === 0) {
          container.innerHTML = `<div class='text-xs text-muted dark:text-muted-dark p-3 flex flex-col gap-2'>
  <div class='flex items-start gap-2'>
    <span>Required variables not present. Include these Monthly Output:Variable objects (or change Frequency to Hourly for higher fidelity).</span>
    <button id='idf-copy-btn' class='shrink-0 p-1 rounded border border-border dark:border-border-dark hover:bg-panel-2 dark:hover:bg-panel-2-dark' title='Copy IDF snippet'>
      <svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' fill='none' stroke='currentColor' stroke-width='1.5' class='w-4 h-4'>
        <path stroke-linecap='round' stroke-linejoin='round' d='M8 16.5h8m-8-4h8m2 8H8.25A2.25 2.25 0 0 1 6 18.75V5.25A2.25 2.25 0 0 1 8.25 3H16.5L21 7.5v11.25A2.25 2.25 0 0 1 18.75 20.5z'/>
        <path stroke-linecap='round' stroke-linejoin='round' d='M16.5 3v4.5H21'/>
      </svg>
    </button>
  </div>
  <pre id='idf-snippet' class='hidden whitespace-pre-wrap text-[10px] leading-snug bg-panel-2 dark:bg-panel-2-dark p-2 rounded border border-border dark:border-border-dark max-h-40 overflow-auto'></pre>
  <button id='idf-toggle' class='self-start text-[10px] px-2 py-1 rounded border border-border dark:border-border-dark hover:bg-panel-2 dark:hover:bg-panel-2-dark'>Show IDF Snippet</button>
</div>`;
          // Attach copy / toggle handlers
          setTimeout(() => {
            const btn = $('idf-copy-btn');
            const pre = $('idf-snippet');
            const toggle = $('idf-toggle');
            if (btn)
              btn.addEventListener('click', () => {
                navigator.clipboard
                  .writeText(IDF_LOAD_BALANCE_SNIPPET)
                  .then(() => {
                    btn.classList.add('bg-accent', 'text-white', 'dark:bg-accent-dark');
                    btn.title = 'Copied!';
                    setTimeout(() => {
                      btn.classList.remove('bg-accent', 'text-white', 'dark:bg-accent-dark');
                      btn.title = 'Copy IDF snippet';
                    }, 1400);
                  })
                  .catch(() => {});
              });
            if (toggle)
              toggle.addEventListener('click', () => {
                if (pre.classList.contains('hidden')) {
                  pre.textContent = IDF_LOAD_BALANCE_SNIPPET;
                  pre.classList.remove('hidden');
                  toggle.textContent = 'Hide IDF Snippet';
                } else {
                  pre.classList.add('hidden');
                  toggle.textContent = 'Show IDF Snippet';
                }
              });
          }, 0);
          return;
        }
        // Prepare stacked dataset; one pseudo series per category
        const paletteLocal = palette; // reuse global palette
        const catSeries = CATS.filter((c) => !missing.includes(c.label)).map((c, i) => ({
          id: c.id,
          meta: { Name: c.label, Units: 'J' },
          color: paletteLocal[i % paletteLocal.length],
          points: monthLabels.map((ml) => ({ xLabel: ml, y: catTotals.get(c.id).get(ml) || 0 })),
        }));
        // Convert to display units (using convertUnits on value in Joules)
        catSeries.forEach((cs) => {
          cs.points.forEach((p) => {
            p.y = convertUnits(p.y, 'J');
          });
        });
        const containerNote = missing.length
          ? `<div class='text-xs text-warning dark:text-warning-dark mb-2'>Missing categories: ${missing.join(
              ', ',
            )}</div>`
          : '';
        // Continue with stacked positive/negative logic
        const m = { top: 16, right: 24, bottom: 56, left: 64 };
        // Measure before clearing so loading overlay (if present) contributes correct size
        const rect = container.getBoundingClientRect();
        if (!hadLoading) container.innerHTML = '';
        const width = rect.width,
          height = rect.height;
        const w = width - m.left - m.right,
          h = height - m.top - m.bottom;
        const {
          axis: axisColor,
          grid: gridColor,
          text: textColor,
          border: borderColor,
          tooltipBg,
        } = chartColors();
        function shortLabel(raw) {
          const m = raw.match(/-M(\d{2})/i);
          if (m) {
            const idx = parseInt(m[1], 10);
            return [
              'Jan',
              'Feb',
              'Mar',
              'Apr',
              'May',
              'Jun',
              'Jul',
              'Aug',
              'Sep',
              'Oct',
              'Nov',
              'Dec',
            ][idx - 1];
          }
          return raw;
        }
        const monthData = monthLabels.map((ml) => {
          const row = { label: ml };
          catSeries.forEach((s) => {
            row[s.id] = s.points.find((p) => p.xLabel === ml)?.y || 0;
          });
          return row;
        });
        const keys = catSeries.map((s) => s.id);
        function stackFiltered(sign) {
          const filtered = monthData.map((r) => {
            const c = { label: r.label };
            keys.forEach((k) => {
              const v = r[k];
              c[k] = sign * v > 0 ? v : 0;
            });
            return c;
          });
          return d3.stack().keys(keys)(filtered);
        }
        const posLayers = stackFiltered(1);
        const negLayers = stackFiltered(-1);
        const maxPos = d3.max(posLayers, (l) => d3.max(l, (d) => d[1])) || 0;
        const maxNeg = d3.min(negLayers, (l) => d3.min(l, (d) => d[0])) || 0;
        const y = d3.scaleLinear().domain([maxNeg, maxPos]).nice().range([h, 0]);
        const x = d3.scaleBand().domain(monthLabels).range([0, w]).padding(0.15);
        if (hadLoading) container.innerHTML = '';
        const svg = d3.select(container).append('svg').attr('width', width).attr('height', height);
        const g = svg.append('g').attr('transform', `translate(${m.left},${m.top})`);
        g.append('g')
          .attr('class', 'grid')
          .call(d3.axisLeft(y).ticks(6).tickSize(-w).tickFormat(''))
          .selectAll('line')
          .attr('stroke', gridColor)
          .attr('stroke-opacity', 0.35);
        g.select('.grid').select('.domain').remove();
        const gx = g
          .append('g')
          .attr('transform', `translate(0,${h})`)
          .call(d3.axisBottom(x).tickFormat(shortLabel));
        const gy = g.append('g').call(d3.axisLeft(y).ticks(6));
        gx.selectAll('path,line').attr('stroke', axisColor);
        gy.selectAll('path,line').attr('stroke', axisColor);
        gx.selectAll('text').attr('fill', axisColor);
        gy.selectAll('text').attr('fill', axisColor);
        g.append('line')
          .attr('x1', 0)
          .attr('x2', w)
          .attr('y1', y(0))
          .attr('y2', y(0))
          .attr('stroke', axisColor)
          .attr('stroke-width', 1.2);
        function drawLayers(layers) {
          layers.forEach((layer) => {
            const color = catSeries.find((s) => s.id === layer.key)?.color || '#999';
            const grp = g.append('g').attr('fill', color);
            grp
              .selectAll('rect')
              .data(layer)
              .enter()
              .append('rect')
              .attr('x', (d) => x(d.data.label))
              .attr('width', x.bandwidth())
              .attr('y', (d) => y(Math.max(d[0], d[1])))
              .attr('height', (d) => Math.abs(y(d[0]) - y(d[1])))
              .append('title')
              .text((d) => {
                const cs = catSeries.find((s) => s.id === layer.key);
                const val = d.data[layer.key];
                return `${shortLabel(d.data.label)}\n${cs?.meta.Name}: ${fmt(
                  val,
                )} ${convertUnitLabel('J')}`;
              });
          });
        }
        drawLayers(posLayers);
        drawLayers(negLayers);
        // Interactive vertical guideline + percentage breakdown tooltip
        let lbTooltip = d3.select(container).select('.lb-tooltip');
        if (lbTooltip.empty()) {
          lbTooltip = d3
            .select(container)
            .append('div')
            .attr('class', 'lb-tooltip')
            .style('position', 'absolute')
            .style('pointer-events', 'none')
            .style('background', tooltipBg)
            .style('border', '1px solid ' + borderColor)
            .style('color', textColor)
            .style('padding', '6px 8px')
            .style('border-radius', '6px')
            .style('font-size', '12px')
            .style('display', 'none');
        }
        const guide = g
          .append('line')
          .attr('class', 'lb-guide')
          .attr('y1', 0)
          .attr('y2', h)
          .attr('stroke', axisColor)
          .attr('stroke-width', 1)
          .attr('stroke-dasharray', '3,3')
          .style('display', 'none');
        const overlay = g
          .append('rect')
          .attr('class', 'lb-overlay')
          .attr('x', 0)
          .attr('y', 0)
          .attr('width', w)
          .attr('height', h)
          .attr('fill', 'transparent')
          .style('cursor', 'crosshair')
          .on('mousemove', function (ev) {
            const [mx] = d3.pointer(ev, this);
            // determine closest month band center
            let closestLabel = null,
              closestDist = Infinity,
              cx = mx;
            monthLabels.forEach((lbl) => {
              const bx = x(lbl) + x.bandwidth() / 2;
              const d = Math.abs(bx - mx);
              if (d < closestDist) {
                closestDist = d;
                closestLabel = lbl;
                cx = bx;
              }
            });
            if (!closestLabel) {
              lbTooltip.style('display', 'none');
              guide.style('display', 'none');
              return;
            }
            guide.style('display', 'block').attr('x1', cx).attr('x2', cx);
            // collect active series (respect hidden toggles)
            const active = catSeries.filter((s) => !s._hidden);
            if (!active.length) {
              lbTooltip.style('display', 'none');
              return;
            }
            // values at this month
            const vals = active.map((s) => ({
              id: s.id,
              name: s.meta.Name,
              color: s.color,
              v: s.points.find((p) => p.xLabel === closestLabel)?.y || 0,
            }));
            // Separate positive / negative totals (for meaningful % of each side)
            const posTotal = d3.sum(
              vals.filter((r) => r.v > 0),
              (r) => r.v,
            );
            const negTotal = Math.abs(
              d3.sum(
                vals.filter((r) => r.v < 0),
                (r) => r.v,
              ),
            );
            // Build rows: show value + % of its sign group; also overall % of absolute sum
            const absTotal = posTotal + negTotal;
            const unitLabel = convertUnitLabel('J');
            const rowsHtml = vals
              .filter((r) => r.v !== 0)
              .sort((a, b) => Math.abs(b.v) - Math.abs(a.v))
              .map((r) => {
                const base = r.v > 0 ? posTotal : negTotal;
                const pctSide = base ? (Math.abs(r.v) / base) * 100 : 0;
                const pctOverall = absTotal ? (Math.abs(r.v) / absTotal) * 100 : 0;
                return `<div><span style="color:${r.color}">${escapeHtml(r.name)}</span> — ${fmt(
                  r.v,
                )} ${unitLabel} <span class='text-muted dark:text-muted-dark'>(${pctSide.toFixed(
                  1,
                )}% of ${r.v > 0 ? 'gains' : 'losses'}, ${pctOverall.toFixed(
                  1,
                )}% total)</span></div>`;
              })
              .join('');
            lbTooltip
              .style('display', 'block')
              .style('left', m.left + cx + 12 + 'px')
              .style('top', m.top + 8 + 'px')
              .html(
                `<div><strong>${shortLabel(closestLabel)}</strong></div>${
                  rowsHtml || '<div class="text-muted dark:text-muted-dark">No values</div>'
                }`,
              );
          })
          .on('mouseleave', () => {
            lbTooltip.style('display', 'none');
            guide.style('display', 'none');
          });
        const leg = $('legend');
        leg.innerHTML = '';
        catSeries.forEach((s) => {
          const btn = document.createElement('button');
          btn.className =
            'text-xs px-2 py-1 rounded border border-border dark:border-border-dark transition-colors bg-panel-2 dark:bg-panel-2-dark';
          btn.innerHTML = `<span style="display:inline-block;width:10px;height:10px;background:${
            s.color
          };border-radius:2px;margin-right:6px;vertical-align:middle"></span>${escapeHtml(
            s.meta.Name,
          )}`;
          btn.onclick = () => {
            // toggle
            if (s._hidden) {
              s._hidden = false;
              btn.classList.add('bg-panel-2', 'dark:bg-panel-2-dark');
            } else {
              s._hidden = true;
              btn.classList.remove('bg-panel-2', 'dark:bg-panel-2-dark');
            }
            // Recompute stacks with hidden series filtered
            const active = catSeries.filter((x) => !x._hidden);
            const keysA = active.map((x) => x.id);
            const monthDataA = monthLabels.map((ml) => {
              const row = { label: ml };
              active.forEach((a) => {
                row[a.id] = a.points.find((p) => p.xLabel === ml)?.y || 0;
              });
              return row;
            });
            function stack(sign) {
              const filtered = monthDataA.map((r) => {
                const c = { label: r.label };
                keysA.forEach((k) => {
                  const v = r[k];
                  c[k] = sign * v > 0 ? v : 0;
                });
                return c;
              });
              return d3.stack().keys(keysA)(filtered);
            }
            const pos = stack(1),
              neg = stack(-1);
            const maxP = d3.max(pos, (l) => d3.max(l, (d) => d[1])) || 0;
            const maxN = d3.min(neg, (l) => d3.min(l, (d) => d[0])) || 0;
            y.domain([maxN, maxP]).nice();
            g.selectAll('.layer').remove();
            function draw(layers) {
              layers.forEach((layer) => {
                const color2 = active.find((a) => a.id === layer.key)?.color || '#999';
                const grp = g.append('g').attr('fill', color2).attr('class', 'layer');
                grp
                  .selectAll('rect')
                  .data(layer)
                  .enter()
                  .append('rect')
                  .attr('x', (d) => x(d.data.label))
                  .attr('width', x.bandwidth())
                  .attr('y', (d) => y(Math.max(d[0], d[1])))
                  .attr('height', (d) => Math.abs(y(d[0]) - y(d[1])))
                  .append('title')
                  .text((d) => {
                    const cs2 = active.find((a) => a.id === layer.key);
                    const val = d.data[layer.key];
                    return `${shortLabel(d.data.label)}\n${cs2?.meta.Name}: ${fmt(
                      val,
                    )} ${convertUnitLabel('J')}`;
                  });
              });
            }
            draw(pos);
            draw(neg);
            g.selectAll('g.grid')
              .call(d3.axisLeft(y).ticks(6).tickSize(-w).tickFormat(''))
              .selectAll('line')
              .attr('stroke', gridColor)
              .attr('stroke-opacity', 0.35);
            g.select('g.grid').select('.domain').remove();
            gy.call(d3.axisLeft(y).ticks(6));
            gy.selectAll('path,line').attr('stroke', axisColor);
            gy.selectAll('text').attr('fill', axisColor);
            // Hide tooltip/guide on restack to avoid stale position referencing removed bars
            lbTooltip.style('display', 'none');
            guide.style('display', 'none');
          };
          leg.appendChild(btn);
        });
        $('insights').innerHTML = `${
          missing.length
            ? '<span class="text-warning dark:text-warning-dark">Partial data; missing: ' +
              missing.join(', ') +
              '</span><br>'
            : ''
        }Load balance (aggregated from available Hourly/Monthly data)`;
        $('units').textContent = convertUnitLabel('J');
      }

      // Signals inputs
      ['search', 'filter-freq', 'filter-meter', 'filter-group', 'fav-only'].forEach((id) =>
        $(id).addEventListener('input', populateDictionaryList),
      );

      $('file-input').addEventListener('change', async (e) => {
        const f = e.target.files[0];
        if (f) await handleFile(f);
      });

      function enableDropZone(el) {
        if (!el) return;
        const highlight = () =>
          el.classList.add(
            'ring-2',
            'ring-accent dark:ring-accent-dark',
            'ring-offset-2',
            'ring-offset-panel dark:ring-offset-panel-dark',
          );
        const unhighlight = () =>
          el.classList.remove(
            'ring-2',
            'ring-accent dark:ring-accent-dark',
            'ring-offset-2',
            'ring-offset-panel dark:ring-offset-panel-dark',
          );
        ['dragenter', 'dragover'].forEach((evt) =>
          el.addEventListener(evt, (e) => {
            e.preventDefault();
            e.stopPropagation();
            highlight();
          }),
        );
        ['dragleave', 'drop'].forEach((evt) =>
          el.addEventListener(evt, (e) => {
            e.preventDefault();
            e.stopPropagation();
            unhighlight();
          }),
        );
        el.addEventListener('drop', async (e) => {
          const f = e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files[0];
          if (f) {
            await handleFile(f);
          }
        });
        el.addEventListener('click', () => {
          const fi = $('file-input');
          if (fi) fi.click();
        });
      }
      enableDropZone($('drop'));

      // Signals section always visible; collapse feature removed.

      async function handleFile(file) {
        await readDbFile(file);
        // Preload D3 early to avoid race when first render triggers before script loads
        try {
          await ensureD3();
        } catch (e) {
          console.warn('d3 preload failed', e);
        }
        const list = queryDictionary();
        populateFilters(list);
        populateDictionaryList();
        restoreSelection();
        // If nothing selected from previous session, auto-select the first meter
        if (selected.size === 0) {
          const firstMeter = list.find((d) => d.IsMeter == 1);
          if (firstMeter) {
            const sel = $('dictionary');
            for (const option of sel.options) {
              if (Number(option.value) === firstMeter.id) {
                option.selected = true;
                break;
              }
            }
            handleSelectionChange();
          }
        }
      }
      function populateFilters(list) {
        const groups = Array.from(new Set(list.map((d) => d.IndexGroup).filter(Boolean))).sort();
        const gSel = $('filter-group');
        gSel.innerHTML =
          `<option value=\"\">Any index group</option>` +
          groups.map((g) => `<option>${escapeHtml(g)}</option>`).join('');
        ['search', 'filter-freq', 'filter-meter', 'filter-group', 'dictionary', 'fav-only'].forEach(
          (id) => ($(id).disabled = false),
        );
        $('meta-count').textContent = `${list.length} entries`;
      }
      function populateDictionaryList() {
        const q = $('search').value.trim().toLowerCase();
        const fFreq = $('filter-freq').value;
        const fMeter = $('filter-meter').value;
        const fGroup = $('filter-group').value;
        const onlyFav = $('fav-only')?.checked;
        const filtered = dict.filter((d) => {
          if (fFreq && d.freq !== fFreq) return false;
          if (fMeter !== '' && String(d.IsMeter) !== fMeter) return false;
          if (fGroup && d.IndexGroup !== fGroup) return false;
          if (onlyFav && !favs.has(d.id)) return false;
          const hay = `${d.Name} ${d.IndexGroup || ''} ${d.key || ''} ${
            d.Units || ''
          }`.toLowerCase();
          return !q || hay.includes(q);
        });
        const sel = $('dictionary');
        sel.innerHTML = filtered
          .map((d) => {
            const star = favs.has(d.id) ? '★ ' : '';
            const tag = d.IsMeter ? 'M' : 'V';
            const units = d.Units ? ` [${escapeHtml(convertUnitLabel(d.Units))}]` : '';
            const key = d.key ? ` (${escapeHtml(d.key)})` : '';
            const label = `${star}${d.freq} | ${d.IndexGroup || '—'} | [${tag}] ${escapeHtml(
              d.Name,
            )}${key}${units}`;
            return `<option value=\"${d.id}\">${label}</option>`;
          })
          .join('');
        $('meta-count').textContent = `${filtered.length} / ${dict.length}`;
      }
      function escapeHtml(s) {
        return String(s).replace(
          /[&<>"']/g,
          (m) =>
            ({
              '&': '&amp;',
              '<': '&lt;',
              '>': '&gt;',
              '"': '&quot;',
              "'": '&#039;',
            })[m],
        );
      }

      $('dictionary').addEventListener('change', handleSelectionChange);
      $('dictionary').addEventListener('dblclick', () => {
        const sel = $('dictionary');
        const opt = sel.selectedOptions[0];
        if (!opt) return;
        const id = Number(opt.value);
        if (favs.has(id)) favs.delete(id);
        else favs.add(id);
        localStorage.setItem(FAVORITES_KEY, JSON.stringify([...favs]));
        populateDictionaryList();
      });

      $('btn-export').addEventListener('click', () => {
        if (selected.size === 0) return;
        downloadFile('series.csv', exportCSV(selected));
      });
      // Zoom button removed; zoom always enabled

      const btnTime = $('view-time'),
        btnLdc = $('view-ldc'),
        btnBalance = $('view-balance'),
        btnScatter = $('view-scatter'),
        chkNorm = $('ldc-normalize');
      btnTime?.addEventListener('click', () => {
        viewMode = 'time';
        btnTime.classList.add('bg-panel-2', 'dark:bg-panel-2-dark');
        btnLdc?.classList.remove('bg-panel-2', 'dark:bg-panel-2-dark');
        btnBalance?.classList.remove('bg-panel-2', 'dark:bg-panel-2-dark');
        $('zoom-hint').classList.add('hidden'); // LDC view (no time zoom)
        renderAll();
      });
      btnLdc?.addEventListener('click', () => {
        viewMode = 'ldc';
        btnLdc.classList.add('bg-panel-2', 'dark:bg-panel-2-dark');
        btnTime?.classList.remove('bg-panel-2', 'dark:bg-panel-2-dark');
        btnBalance?.classList.remove('bg-panel-2', 'dark:bg-panel-2-dark');
        $('zoom-hint').classList.add('hidden');
        renderAll();
      });
      btnBalance?.addEventListener('click', () => {
        viewMode = 'balance';
        btnBalance.classList.add('bg-panel-2', 'dark:bg-panel-2-dark');
        btnTime?.classList.remove('bg-panel-2', 'dark:bg-panel-2-dark');
        btnLdc?.classList.remove('bg-panel-2', 'dark:bg-panel-2-dark');
        btnScatter?.classList.remove('bg-panel-2', 'dark:bg-panel-2-dark');
        $('zoom-hint').classList.add('hidden');
        renderAll();
      });
      btnScatter?.addEventListener('click', () => {
        viewMode = 'scatter';
        btnScatter.classList.add('bg-panel-2', 'dark:bg-panel-2-dark');
        btnTime?.classList.remove('bg-panel-2', 'dark:bg-panel-2-dark');
        btnLdc?.classList.remove('bg-panel-2', 'dark:bg-panel-2-dark');
        btnBalance?.classList.remove('bg-panel-2', 'dark:bg-panel-2-dark');
        $('zoom-hint').classList.add('hidden');
        renderAll();
      });
      chkNorm?.addEventListener('change', () => {
        // Always re-render; normalization now applies to both time & LDC views
        renderAll();
      });

      function restoreSelection() {
        try {
          const raw = localStorage.getItem(SELECT_KEY);
          if (!raw) return;
          const ids = JSON.parse(raw);
          const sel = $('dictionary');
          for (const option of sel.options) {
            if (ids.includes(Number(option.value))) option.selected = true;
          }
          handleSelectionChange();
        } catch {}
      }
      // Responsive resize: observe chart container; throttle with rAF for smooth live resizing
      (function () {
        const chartEl = document.getElementById('chart');
        if (!chartEl || typeof ResizeObserver === 'undefined') return;
        let frame = null;
        let lastW = 0,
          lastH = 0;
        const ro = new ResizeObserver((entries) => {
          const cr = entries[0].contentRect;
          if (Math.abs(cr.width - lastW) < 1 && Math.abs(cr.height - lastH) < 1) return;
          lastW = cr.width;
          lastH = cr.height;
          if (frame) return; // already scheduled
          frame = requestAnimationFrame(() => {
            frame = null;
            if (selected.size) {
              renderAll();
            }
          });
        });
        ro.observe(chartEl);
        // also listen to window resize for layout shifts affecting chart width indirectly (e.g., sidebar collapse)
        window.addEventListener('resize', () => {
          if (frame) return;
          frame = requestAnimationFrame(() => {
            frame = null;
            if (selected.size) {
              renderAll();
            }
          });
        });
      })();

      (function () {
        try {
          console.assert(fmt(1000) === '1.00k', 'fmt k');
          const st = computeStats([1, 2, 3, 4]);
          console.assert(
            st.count === 4 && st.min === 1 && st.max === 4 && Math.abs(st.mean - 2.5) < 1e-9,
            'stats',
          );
          const ptsH = toHourlyPoints([{ value: 1, env: 1, month: 1, day: 1, hour: 0, minute: 0 }]);
          console.assert(ptsH.length === 1 && typeof ptsH[0].x === 'number', 'hourly points');
          const ptsM = toMonthlyPoints([{ value: 5, env: 2, month: 7 }]);
          console.assert(ptsM.length === 1 && ptsM[0].xLabel.startsWith('E2-'), 'monthly points');
          const m = new Map([[1, { meta: { Units: 'W' }, points: [{ xLabel: 'L', y: 3 }] }]]);
          const csv = exportCSV(m);
          console.assert(
            /label,value,series_id/.test(csv) || /datetime_utc/.test(csv),
            'csv header',
          );
          console.assert(escapeHtml('<tag>') === '&lt;tag&gt;', 'escapeHtml');
          console.assert(typeof zoomEnabled === 'boolean', 'zoom flag exists');
          const ldc = toLDC([{ y: 1 }, { y: 3 }, { y: 2 }], 'W', false);
          console.assert(ldc.length === 3 && ldc[0].y >= ldc[1].y, 'ldc sorted');
          console.assert(viewMode === 'time', 'default view mode time');
          const normEl = document.getElementById('ldc-normalize');
          console.assert(normEl && normEl.checked === false, 'ldc normalize default OFF');
          const _oldIP = isIP,
            _esi = prefEnergySI,
            _eip = prefEnergyIP,
            _pip = prefPowerIP;
          isIP = false;
          prefEnergySI = 'kWh';
          console.assert(Math.abs(convertUnits(3.6e6, 'J') - 1) < 1e-9, 'SI kWh scaling');
          isIP = true;
          prefEnergyIP = 'kBTU';
          console.assert(Math.abs(convertUnits(1055.06, 'J') - 1) < 5e-3, 'IP kBTU scaling');
          prefPowerIP = 'Tons';
          console.assert(Math.abs(convertUnits(12000, 'Btu/h') - 1) < 1e-9, 'IP Tons scaling');
          isIP = _oldIP;
          prefEnergySI = _esi;
          prefEnergyIP = _eip;
          prefPowerIP = _pip;
          console.info('Self-tests passed');
        } catch (e) {
          console.warn('Self-tests failed', e);
        }
      })();
    </script>
  </body>
</html>
